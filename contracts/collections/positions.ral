Contract Positions(admin: Address, positionTemplateContractId: ByteVec, clammContractId: ByteVec, positionsCounterContractId: ByteVec) {
    enum PositionsError {
        NotAdmin = 2001
        NotFound = 2002
        TooManyPositions = 2003
    }
    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn add(
        caller: Address,
        poolKey: ByteVec,
        liquidityDelta: U256,
        lowerTickIdx: I256,
        upperTickIdx: I256,
        lastBlock: U256,
        feeX: U256,
        feeY: U256,
        tokensX: U256,
        tokensY: U256
    ) -> ByteVec {
        assert!(callerAddress!() == admin, PositionsError.NotAdmin)
        // let length = getLength(caller, poolKey)
        let length = 0
        let (encodedImmFields, encodedMutFields) = Position.encodeFields!(poolKey, liquidityDelta, lowerTickIdx, upperTickIdx, feeX, feeY, lastBlock, tokensX, tokensY, true, clammContractId)
        let positionId = copyCreateSubContract!{caller -> ALPH: 1 alph}(
            poolKey ++ toByteVec!(caller) ++ toByteVec!(length),
            positionTemplateContractId,
            encodedImmFields,
            encodedMutFields
        )
        assert!(contractExists!(positionId), 420)
        // PositionsCounter(positionsCounterContractId ++ toByteVec!(caller)).increment()
        wrappedModify(positionId)
        return positionId
    }

    @using(checkExternalCaller = false)
    pub fn remove(caller: Address, poolKey: ByteVec, index: U256) -> () {
        assert!(callerAddress!() == admin, PositionsError.NotAdmin)
        let length = getLength(caller, poolKey)
        assert!(length - 1 >= index, PositionsError.NotFound)
        let position = Position(positionsCounterContractId ++ toByteVec!(caller) ++ toByteVec!(index))
        assert!(!position.getIsOpen(), PositionsError.NotFound)
        position.close()
        return
    }

    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn transfer(caller: Address, recipient: Address, poolKey: ByteVec, index: U256) -> () {
        assert!(callerAddress!() == admin, PositionsError.NotAdmin)
        let ownerLength = getLength(caller, poolKey)
        assert!(ownerLength - 1 >= index, PositionsError.NotFound)
        let position = Position(positionTemplateContractId ++ toByteVec!(caller) ++ toByteVec!(index))
        assert!(position.getIsOpen(), PositionsError.NotFound)
        remove(caller, poolKey, index)
        add{caller -> ALPH: 1 alph}(recipient, position.getRelatedPoolKey(), position.getPosLiquidity(), position.getPosLowerTickIndex(), position.getPosUpperTickIndex(), position.getLastBlockNumber(), position.getPosFeeGrowthInsideX(), position.getPosFeeGrowthInsideY(), position.getPosTokensOwedX(), position.getPosTokensOwedY())
        return
    }


    pub fn getIds(caller: Address, poolKey: ByteVec) -> [ByteVec; 100] {
        let length = getLength(caller, poolKey)
        assert!(length <= 100, PositionsError.TooManyPositions)
        let mut ids = [toByteVec!(0); 100]
        for (let mut i = 0; i < length; i = i + 1) {
            ids[i] = poolKey ++ toByteVec!(caller) ++ toByteVec!(i)
        }
        return ids
    }
    fn getLength(owner: Address, poolKey: ByteVec) -> U256 {
        if(contractExists!(subContractId!(positionsCounterContractId ++ toByteVec!(owner)))) {
            return PositionsCounter(positionsCounterContractId ++ toByteVec!(owner)).get()
        } else {
            let (counterEncodedImmFields, counterEncodedMutFields) = PositionsCounter.encodeFields!(admin, 0)
            copyCreateSubContract!{owner -> ALPH: 1 alph}(
                poolKey ++ toByteVec!(owner),
                positionsCounterContractId,
                counterEncodedImmFields,
                counterEncodedMutFields
            )
            return 0   
        }
    }

    @using(checkExternalCaller = false)
    pub fn wrappedModify(
        positionId: ByteVec
        // lowerTickIndex: I256,
        // lowerTickFeeGrowthOutsideX: U256,
        // lowerTickFeeGrowthOutsideY: U256,
        // upperTickIndex: I256,
        // upperTickFeeGrowthOutsideX: U256,
        // upperTickFeeGrowthOutsideY: U256,
        // poolIndex: I256,
        // poolFeeGrowthGlobalX: U256,
        // poolFeeGrowthGlobalY: U256,
        // add: Bool,
        // liquidityDelta: U256
    ) -> () {
        assert!(contractExists!(positionId), 12387019283098109238018203)
        let position = Position(subContractId!(positionId))
        position.modify(
        //     lowerTickIndex,
        //     lowerTickFeeGrowthOutsideX,
        //     lowerTickFeeGrowthOutsideY,
        //     upperTickIndex,
        //     upperTickFeeGrowthOutsideX,
        //     upperTickFeeGrowthOutsideY,
        //     poolIndex,
        //     poolFeeGrowthGlobalX,
        //     poolFeeGrowthGlobalY,
        //     add,
        //     liquidityDelta
        )
    }



    pub fn getId(caller: Address, poolKey: ByteVec, index: U256) -> ByteVec {
        return subContractId!(poolKey ++ toByteVec!(caller) ++ toByteVec!(index))
    }

    pub fn get(owner: Address, index: U256, poolKey: ByteVec) -> (Bool, ByteVec) {
        let positionId = poolKey ++ toByteVec!(owner) ++ toByteVec!(index)
        
        let mut positionBytes = b``
        
        let subContractId = subContractId!(positionId)

        if (!contractExists!(subContractId)) {
            return false, b``
        }

        let contract = Position(subContractId)
        positionBytes = positionBytes
        ++ toByteVec!(contract.getPosLiquidity()) ++ b`break` 
        ++ toByteVec!(contract.getPosLowerTickIndex()) ++ b`break` 
        ++ toByteVec!(contract.getPosUpperTickIndex()) ++ b`break` 
        ++ toByteVec!(contract.getPosFeeGrowthInsideX()) ++ b`break`
        ++ toByteVec!(contract.getPosFeeGrowthInsideY()) ++ b`break`
        ++ toByteVec!(contract.getLastBlockNumber()) ++ b`break`
        ++ toByteVec!(contract.getPosTokensOwedX()) ++ b`break`
        ++ toByteVec!(contract.getPosTokensOwedY())

        return true, positionBytes
    }
}