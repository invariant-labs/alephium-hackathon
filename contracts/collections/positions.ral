Contract Positions(positionTemplateContractId: ByteVec, positionsCounterTemplateId: ByteVec) {
    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn add(
        caller: Address,
        poolKey: ByteVec,
        liquidity: U256,
        lowerTickIndex: I256,
        upperTickIndex: I256,
        feeGrowthInsideX: U256,
        feeGrowthInsideY: U256,
        lastBlockNumber: U256,
        tokensOwedX: U256,
        tokensOwedY: U256
    ) -> () {
        let length = getLength(caller)

        if (length == 0) {
            let (positionsCounterEncodedImmFields, positionsCounterEncodedMutFields) = PositionsCounter.encodeFields!(1)
            copyCreateSubContract!{caller -> ALPH: 1 alph}(
                toByteVec!(caller),
                positionsCounterTemplateId,
                positionsCounterEncodedImmFields,
                positionsCounterEncodedMutFields
            )
        } else {
            let contract = PositionsCounter(subContractId!(toByteVec!(caller)))
            contract.set(contract.get() + 1)
        }

        let (encodedImmFields, encodedMutFields) = Position.encodeFields!(
            poolKey,
            liquidity,
            lowerTickIndex,
            upperTickIndex,
            feeGrowthInsideX,
            feeGrowthInsideY,
            lastBlockNumber,
            tokensOwedX,
            tokensOwedY
        )
        copyCreateSubContract!{caller -> ALPH: 1 alph}(
            toByteVec!(caller) ++ toByteVec!(length + 1),
            positionTemplateContractId,
            encodedImmFields,
            encodedMutFields
        )
    }

    fn getLength(owner: Address) -> U256 {
        let subContractId = subContractId!(toByteVec!(owner))

        if(contractExists!(subContractId)) {
            return PositionsCounter(subContractId).get()
        } else {
            return 0
        }
    }

    pub fn getPoolKey(owner: Address, index: U256) -> ByteVec {
        let subContractId = subContractId!(toByteVec!(owner) ++ toByteVec!(index))
        return Position(subContractId).getPoolKey()
    }

    pub fn getLowerTickIndex(owner: Address, index: U256) -> I256 {
        let subContractId = subContractId!(toByteVec!(owner) ++ toByteVec!(index))
        return Position(subContractId).getLowerTickIndex()
    }

    pub fn getUpperTickIndex(owner: Address, index: U256) -> I256 {
        let subContractId = subContractId!(toByteVec!(owner) ++ toByteVec!(index))
        return Position(subContractId).getUpperTickIndex()
    }

    pub fn getLiquidity(owner: Address, index: U256) -> U256 {
        let subContractId = subContractId!(toByteVec!(owner) ++ toByteVec!(index))
        return Position(subContractId).getLiquidity()
    }

    pub fn getTokensOwedX(owner: Address, index: U256) -> U256 {
        let subContractId = subContractId!(toByteVec!(owner) ++ toByteVec!(index))
        return Position(subContractId).getTokensOwedX()
    }

    pub fn getTokensOwedY(owner: Address, index: U256) -> U256 {
        let subContractId = subContractId!(toByteVec!(owner) ++ toByteVec!(index))
        return Position(subContractId).getTokensOwedY()
    }

    @using(checkExternalCaller = false)
    pub fn setTokensOwedX(owner: Address, index: U256, value: U256) -> () {
        let subContractId = subContractId!(toByteVec!(owner) ++ toByteVec!(index))
        Position(subContractId).setTokensOwedX(value)
    }

    @using(checkExternalCaller = false)
    pub fn setTokensOwedY(owner: Address, index: U256, value: U256) -> () {
        let subContractId = subContractId!(toByteVec!(owner) ++ toByteVec!(index))
        Position(subContractId).setTokensOwedY(value)
    }

    @using(checkExternalCaller = false)
    pub fn update(
        owner: Address,
        index: U256,
        sign: Bool,
        liquidityDelta: U256,
        feeGrowthInsideX: U256,
        feeGrowthInsideY: U256
    ) -> () {
        Position(subContractId!(toByteVec!(owner) ++ toByteVec!(index))).update(sign, liquidityDelta, feeGrowthInsideX, feeGrowthInsideY)
    }

    pub fn get(owner: Address, index: U256) -> (Bool, U256, I256, I256, U256, U256, U256, U256, U256) {
        let subContractId = subContractId!(toByteVec!(owner) ++ toByteVec!(index))
        
        if (!contractExists!(subContractId)) {
            return false, 0, 0i, 0i, 0, 0, 0, 0, 0
        } else {
            return true, Position(subContractId).get()
        }
    }

    @using(checkExternalCaller = false)
    pub fn wrappedModify(
        caller: Address,
        index: U256,
        poolsContractId: ByteVec,
        ticksContractId: ByteVec,
        clammContractId: ByteVec,
        poolKey: ByteVec,
        upperTick: I256,
        lowerTick: I256,
        liquidityDelta: U256,
        add: Bool,
        currentTimestamp: U256,
        tickSpacing: U256
    ) -> (U256, U256) {
        return Position(subContractId!(toByteVec!(caller) ++ toByteVec!(index))).modify(poolsContractId, ticksContractId, clammContractId, poolKey, upperTick, lowerTick, liquidityDelta, add, currentTimestamp, tickSpacing)
    }
}