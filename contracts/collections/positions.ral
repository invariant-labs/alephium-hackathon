Contract Positions(positionTemplateContractId: ByteVec, positionsCounterContractId: ByteVec, mut invariantId: ByteVec, mut areAdminsSet: Bool) {
    enum PositionsError {
        NotOwner = 500
        PositionNotExist = 501
        NotAdmin = 502
        AdminsAreSet = 503
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn setAdmins(invariant: ByteVec) -> () {
        assert!(!areAdminsSet, PositionsError.AdminsAreSet)
        invariantId = invariant
        PositionsCounter(positionsCounterContractId).setAdmins(toByteVec!(selfAddress!()))
        areAdminsSet = true
    }

    @using(checkExternalCaller = false)
    pub fn getSelfId() -> ByteVec {
        return toByteVec!(selfAddress!())
    }

    @using(preapprovedAssets = true)
    pub fn add(
        caller: Address,
        poolKey: ByteVec,
        liquidity: U256,
        lowerTickIndex: I256,
        upperTickIndex: I256,
        feeGrowthInsideX: U256,
        feeGrowthInsideY: U256,
        lastBlockNumber: U256,
        tokensOwedX: U256,
        tokensOwedY: U256
    ) -> () {
        let callerId = toByteVec!(callerAddress!())
        checkCaller!(callerId == invariantId && areAdminsSet, PositionsError.NotAdmin)
    

        let positionsCounter = PositionsCounter(positionsCounterContractId)
        let length = positionsCounter.get()
        positionsCounter.set(length + 1)

        let (encodedImmFields, encodedMutFields) = Position.encodeFields!(
            getSelfId(),
            poolKey,
            liquidity,
            lowerTickIndex,
            upperTickIndex,
            feeGrowthInsideX,
            feeGrowthInsideY,
            lastBlockNumber,
            tokensOwedX,
            tokensOwedY,
            caller,
            true
        )
        copyCreateSubContract!{caller -> ALPH: 1 alph}(
            toByteVec!(length + 1),
            positionTemplateContractId,
            encodedImmFields,
            encodedMutFields
        )
    }

    pub fn remove(caller: Address, index: U256) -> () {
        let callerId = toByteVec!(callerAddress!())
        checkCaller!(callerId == invariantId && areAdminsSet, PositionsError.NotAdmin)

        let subContractId = subContractId!(toByteVec!(index))
        assert!(contractExists!(subContractId), PositionsError.PositionNotExist)
        let position = Position(subContractId)
        assert!(position.getOwner() == caller, PositionsError.NotOwner)
        position.setIsActive(false)
    }

    pub fn transfer(caller: Address, index: U256, newOwner: Address) -> () {
        let callerId = toByteVec!(callerAddress!())
        checkCaller!(callerId == invariantId && areAdminsSet, PositionsError.NotAdmin)

        let subContractId = subContractId!(toByteVec!(index))
        assert!(contractExists!(subContractId), PositionsError.PositionNotExist)
        let position = Position(subContractId)
        assert!(position.getOwner() == caller, PositionsError.NotOwner)
        position.setOwner(newOwner)
    }

    pub fn getPoolKey(index: U256) -> ByteVec {
        let subContractId = subContractId!(toByteVec!(index))
        return Position(subContractId).getPoolKey()
    }

    pub fn getLowerTickIndex(index: U256) -> I256 {
        let subContractId = subContractId!(toByteVec!(index))
        return Position(subContractId).getLowerTickIndex()
    }

    pub fn getUpperTickIndex(index: U256) -> I256 {
        let subContractId = subContractId!(toByteVec!(index))
        return Position(subContractId).getUpperTickIndex()
    }

    pub fn getLiquidity(index: U256) -> U256 {
        let subContractId = subContractId!(toByteVec!(index))
        return Position(subContractId).getLiquidity()
    }

    pub fn getTokensOwedX(index: U256) -> U256 {
        let subContractId = subContractId!(toByteVec!(index))
        return Position(subContractId).getTokensOwedX()
    }

    pub fn getTokensOwedY(index: U256) -> U256 {
        let subContractId = subContractId!(toByteVec!(index))
        return Position(subContractId).getTokensOwedY()
    }

    pub fn setTokensOwedX(index: U256, value: U256) -> () {
        let callerId = toByteVec!(callerAddress!())
        checkCaller!(callerId == invariantId && areAdminsSet, PositionsError.NotAdmin)

        let subContractId = subContractId!(toByteVec!(index))
        Position(subContractId).setTokensOwedX(value)
    }

    pub fn setTokensOwedY(index: U256, value: U256) -> () {
        let callerId = toByteVec!(callerAddress!())
        checkCaller!(callerId == invariantId && areAdminsSet, PositionsError.NotAdmin)

        let subContractId = subContractId!(toByteVec!(index))
        Position(subContractId).setTokensOwedY(value)
    }

    pub fn update(
        index: U256,
        sign: Bool,
        liquidityDelta: U256,
        feeGrowthInsideX: U256,
        feeGrowthInsideY: U256
    ) -> () {
        let callerId = toByteVec!(callerAddress!())
        checkCaller!(callerId == invariantId && areAdminsSet, PositionsError.NotAdmin)

        Position(subContractId!(toByteVec!(index))).update(sign, liquidityDelta, feeGrowthInsideX, feeGrowthInsideY)
    }

    pub fn get(index: U256) -> (Bool, U256, I256, I256, U256, U256, U256, U256, U256) {
        let subContractId = subContractId!(toByteVec!(index))
        
        if (!contractExists!(subContractId)) {
            return false, 0, 0i, 0i, 0, 0, 0, 0, 0
        } else {
            return true, Position(subContractId).get()
        }
    }

    pub fn wrappedModify(
        index: U256,
        poolsContractId: ByteVec,
        ticksContractId: ByteVec,
        clammContractId: ByteVec,
        poolKey: ByteVec,
        upperTick: I256,
        lowerTick: I256,
        liquidityDelta: U256,
        add: Bool,
        currentTimestamp: U256,
        tickSpacing: U256
    ) -> (U256, U256) {
        let callerId = toByteVec!(callerAddress!())
        checkCaller!(callerId == invariantId && areAdminsSet, PositionsError.NotAdmin)

        let pools = Pools(poolsContractId)
        pools.setLastTimestamp(poolKey, currentTimestamp)

        let maxLiquidityPerTick = CLAMM(clammContractId).calculateMaxLiquidityPerTick(tickSpacing)

        let ticks = Ticks(ticksContractId)

        ticks.updateTick(poolKey, lowerTick, liquidityDelta, maxLiquidityPerTick, false, add)
        ticks.updateTick(poolKey, upperTick, liquidityDelta, maxLiquidityPerTick, true, add)

        let (lowerTickFeeGrowthOutsideX, lowerTickFeeGrowthOutsideY) = ticks.getFeeGrowthOutside(poolKey, lowerTick)
        let (upperTickFeeGrowthOutsideX, upperTickFeeGrowthOutsideY) = ticks.getFeeGrowthOutside(poolKey, upperTick)
        let poolCurrentTickIndex = pools.getCurrentTickIndex(poolKey)
        let (poolFeeGrowthGlobalX, poolFeeGrowthGlobalY) = pools.getFeeGrowthGlobal(poolKey)

        Position(subContractId!(toByteVec!(index))).modify(
            clammContractId,
            upperTick,
            upperTickFeeGrowthOutsideX,
            upperTickFeeGrowthOutsideY,
            lowerTick,
            lowerTickFeeGrowthOutsideX,
            lowerTickFeeGrowthOutsideY,
            poolCurrentTickIndex,
            poolFeeGrowthGlobalX,
            poolFeeGrowthGlobalY,
            liquidityDelta,
            add
        )

        return pools.updateLiquidity(poolKey, liquidityDelta, add, upperTick, lowerTick)
    }
}