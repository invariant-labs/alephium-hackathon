Contract PoolKeys(admin: Address, poolKeyTemplateContractId: ByteVec, mut poolKeyCount: U256) {
    enum PoolKeysError {
        NotAdmin = 200
        PoolKeyAlreadyExist = 201
    }

    @using(preapprovedAssets = true, updateFields = true, checkExternalCaller = false)
    pub fn add(originalCaller: Address, token0: Address, token1: Address, fee: U256, tickSpacing: U256) -> () {
        assert!(callerAddress!() == admin, PoolKeysError.NotAdmin)

        for (let mut i = 1; i <= poolKeyCount; i = i + 1) {
            let contract = PoolKey(subContractId!(toByteVec!(i)))
    
            assert!(token0 != contract.getToken0() || token1 != contract.getToken1() || fee != contract.getFee() || tickSpacing != contract.getTickSpacing(), PoolKeysError.PoolKeyAlreadyExist)
        }
    
        poolKeyCount = poolKeyCount + 1
        let (encodedImmFields, encodedMutFields) = PoolKey.encodeFields!(token0, token1, fee, tickSpacing)
        copyCreateSubContract!{originalCaller -> ALPH: 1 alph}(
            toByteVec!(i),
            poolKeyTemplateContractId,
            encodedImmFields,
            encodedMutFields
        )
    }

    pub fn contains(token0: Address, token1: Address, fee: U256, tickSpacing: U256) -> Bool {
        for (let mut i = 1; i <= poolKeyCount; i = i + 1) {
            let contract = PoolKey(subContractId!(toByteVec!(i)))

            if (token0 == contract.getToken0() && token1 == contract.getToken1() && fee == contract.getFee() && tickSpacing == contract.getTickSpacing()) {
                return true
            }
        }

        return false
    }

    pub fn getAll() -> ByteVec {
        let mut poolsBytes = b``

        for (let mut i = 1; i <= poolKeyCount; i = i + 1) {
            let contract = PoolKey(subContractId!(toByteVec!(i)))
            poolsBytes = poolsBytes ++ toByteVec!(contract.getToken0()) ++ b`break` ++ toByteVec!(contract.getToken1()) ++ b`break` ++ toByteVec!(contract.getFee()) ++ b`break` ++ toByteVec!(contract.getTickSpacing()) ++ b`break`
        }

        return poolsBytes
    }
}