Abstract Contract PoolKeys() {
    @using(preapprovedAssets = true, updateFields = true)
    fn addPoolKey(originalCaller: Address, poolKey: PoolKey) -> () {
        assert!(!containsPoolKey(poolKey), InvariantError.PoolKeyAlreadyExist)
    
        poolKeyCount = poolKeyCount + 1

        poolKeys.insert!(originalCaller, poolKeyCount, poolKey)
    }

    fn containsPoolKey(poolKey: PoolKey) -> Bool {
        for (let mut i = 1; i <= poolKeyCount; i = i + 1) {
            let state = poolKeys[i]

            if (poolKey.tokenX == state.tokenX && poolKey.tokenY == state.tokenY && poolKey.feeTier.fee == state.feeTier.fee && poolKey.feeTier.tickSpacing == state.feeTier.tickSpacing) {
                return true
            }
        }

        return false
    }

    // fn getAllPoolKeys() -> ByteVec {
    //     let mut poolKeysBytes = b``

    //     for (let mut i = 1; i <= poolKeyCount; i = i + 1) {
    //         let state = poolKeys[i]
    //         poolKeysBytes = poolKeysBytes ++ state.tokenX ++ b`break` ++ state.tokenY ++ b`break` ++ toByteVec!(state.feeTier.fee) ++ b`break` ++ toByteVec!(state.feeTier.tickSpacing) ++ b`break`
    //     }

    //     return poolKeysBytes
    // }
}