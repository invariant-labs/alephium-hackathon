Contract Pools(
    clamm: CLAMM,
    mut invariantId: Address,
    mut areAdminsSet: Bool
) extends PoolKeyHelper(), PoolHelper(clamm) {
    // Key: PoolKey
    mapping[ByteVec, Pool] pools

    enum PoolsError {
        NotAdmin = 300
        AdminsAreSet = 301
        PoolAlreadyExist = 302
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn setAdmins(invariant: Address) -> () {
        assert!(!areAdminsSet, PoolsError.AdminsAreSet)
        invariantId = invariant
        areAdminsSet = true
    }

    @using(preapprovedAssets = true)
    pub fn add(
        originalCaller: Address,
        poolKey: ByteVec,
        tokenX: ByteVec,
        tokenY: ByteVec,
        tickSpacing: U256,
        initSqrtPrice: U256,
        initTick: I256,
        currentTimestamp: U256,
        feeReceiver: Address
    ) -> () {
        let caller = callerAddress!()
        checkCaller!((caller == invariantId) && areAdminsSet, PoolsError.NotAdmin)

        assert!(!contains(poolKey), PoolsError.PoolAlreadyExist)

        let state = Pool {
            tokenX: tokenX,
            tokenY: tokenY,
            tickSpacing: tickSpacing,
            liquidity: 0,
            sqrtPrice: initSqrtPrice,
            currentTickIndex: initTick,
            feeGrowthGlobalX: 0,
            feeGrowthGlobalY: 0,
            feeProtocolTokenX: 0,
            feeProtocolTokenY: 0,
            startTimestamp: currentTimestamp,
            lastTimestamp: currentTimestamp,
            feeReceiver: feeReceiver
        }
        pools.insert!(originalCaller, poolKey, state)
    }

    pub fn contains(poolKey: ByteVec) -> Bool {
        return pools.contains!(poolKey)
    }

    pub fn getToken(poolKey: ByteVec) -> (ByteVec, ByteVec) {
        let state = pools[poolKey]
        return state.tokenX, state.tokenY
    }

    pub fn getTickSpacing(poolKey: ByteVec) -> U256 {
        return pools[poolKey].tickSpacing
    }

    pub fn getLiquidity(poolKey: ByteVec) -> U256 {
        return pools[poolKey].liquidity
    }

    pub fn getSqrtPrice(poolKey: ByteVec) -> U256 {
        return pools[poolKey].sqrtPrice
    }

    pub fn getCurrentTickIndex(poolKey: ByteVec) -> I256 {
        return pools[poolKey].currentTickIndex
    }

    pub fn getFeeGrowthGlobal(poolKey: ByteVec) -> (U256, U256) {
        let state = pools[poolKey]
        return state.feeGrowthGlobalX, state.feeGrowthGlobalY
    }

    pub fn getStartTimestamp(poolKey: ByteVec) -> U256 {
        return pools[poolKey].startTimestamp
    }

    pub fn getFeeReceiver(poolKey: ByteVec) -> Address {
        return pools[poolKey].feeReceiver
    }

    pub fn setSqrtPrice(poolKey: ByteVec, sqrtPrice: U256) -> () {
        let caller = callerAddress!()
        checkCaller!((caller == invariantId) && areAdminsSet, PoolsError.NotAdmin)
        let mut state = pools[poolKey]
        state.sqrtPrice = sqrtPrice
        pools[poolKey] = state
    }

    pub fn setCurrentTickIndex(poolKey: ByteVec, tickIndex: I256) -> () {
        let caller = callerAddress!()
        checkCaller!((caller == invariantId) && areAdminsSet, PoolsError.NotAdmin)
        let mut state = pools[poolKey]
        state.currentTickIndex = tickIndex
        pools[poolKey] = state
    }

    pub fn setLastTimestamp(poolKey: ByteVec, timestamp: U256) -> () {
        let caller = callerAddress!()
        checkCaller!((caller == invariantId) && areAdminsSet, PoolsError.NotAdmin)
        let mut state = pools[poolKey]
        state.lastTimestamp = timestamp
        pools[poolKey] = state
    }

    pub fn setFeeReceiver(poolKey: ByteVec, newReceiver: Address) -> () {
        let caller = callerAddress!()
        checkCaller!((caller == invariantId) && areAdminsSet, PoolsError.NotAdmin)
        let mut state = pools[poolKey]
        state.feeReceiver = newReceiver
        pools[poolKey] = state
    }

    pub fn get(poolKey: ByteVec) -> (Bool, Pool) {
        if(contains(poolKey)) {
            return true, pools[poolKey]
        } else {   
            return false,
            Pool {
                tokenX: #,
                tokenY: #,
                tickSpacing: 0,
                liquidity: 0,
                sqrtPrice: 0,
                currentTickIndex: 0i,
                feeGrowthGlobalX: 0,
                feeGrowthGlobalY: 0,
                feeProtocolTokenX: 0,
                feeProtocolTokenY: 0,
                startTimestamp: 0,
                lastTimestamp: 0,
                feeReceiver: byteVecToAddress!(#)
            }
        } 
    }

    pub fn wrappedAddFee(poolKey: ByteVec, feeAmount: U256, xToY: Bool, fee: U256) -> () {
        let caller = callerAddress!()
        checkCaller!((caller == invariantId) && areAdminsSet, PoolsError.NotAdmin)
        let pool = pools[poolKey]
        let updatedPool = addFee(pool, feeAmount, xToY, fee)
        pools[poolKey] = updatedPool
    }

    pub fn wrappedCrossTick(
        poolKey: ByteVec,
        nextSqrtPrice: U256,
        swapLimit: U256,
        tickIndex: I256,
        remainingAmount: U256,
        byAmountIn: Bool,
        xToY: Bool,
        protocolFee: U256,
        fee: U256,
        tickSpacing: U256
    ) -> (U256, U256, Bool) {
        let caller = callerAddress!()
        checkCaller!((caller == invariantId) && areAdminsSet, PoolsError.NotAdmin)

        let (totalAmount, amountLeft, hasCrossed, updatedPool) = crossTick(
            pools[poolKey],
            nextSqrtPrice,
            swapLimit,
            tickIndex,
            remainingAmount,
            byAmountIn,
            xToY,
            protocolFee,
            fee,
            tickSpacing
        )
        pools[poolKey] = updatedPool

        return totalAmount, amountLeft, hasCrossed
    }

    pub fn wrappedCrossLiquidityUpdate(
        poolKey: ByteVec,
        add: Bool,
        liquidityDelta: U256
    ) -> () {
        let caller = callerAddress!()
        checkCaller!((caller == invariantId) && areAdminsSet, PoolsError.NotAdmin)

        let pool = crossLiquidityUpdate(pools[poolKey], add, liquidityDelta)
        pools[poolKey] = pool
        return
    }

    pub fn wrappedUpdateLiquidity(poolKey: ByteVec, liquidityDelta: U256, liquiditySign: Bool, upperTick: I256, lowerTick: I256) -> (U256, U256) {
        let caller = callerAddress!()
        checkCaller!((caller == invariantId) && areAdminsSet, PoolsError.NotAdmin)
        let (x, y, pool) = updateLiquidity(pools[poolKey], liquidityDelta, liquiditySign, upperTick, lowerTick)
        pools[poolKey] = pool
        return x, y
    }

    pub fn wrappedWithdrawProtocolFee(poolKey: ByteVec) -> (U256, U256) {
        let caller = callerAddress!()
        checkCaller!((caller == invariantId) && areAdminsSet, PoolsError.NotAdmin)

        let (feeProtocolTokenX, feeProtocolTokenY, pool) = withdrawProtocolFee(pools[poolKey])
        pools[poolKey] = pool
        return feeProtocolTokenX, feeProtocolTokenY
    }
}