Abstract Contract Pools(clamm: CLAMM) extends PoolKeyHelper(), PoolHelper(clamm) {
    @using(preapprovedAssets = true)
    fn addPool(
        originalCaller: Address,
        poolKey: PoolKey,
        initSqrtPrice: U256,
        initTick: I256,
        currentTimestamp: U256,
        feeReceiver: Address
    ) -> () {
        assert!(!containsPool(poolKey), InvariantError.PoolAlreadyExist)

        let state = Pool {
            poolKey: poolKey,
            liquidity: 0,
            sqrtPrice: initSqrtPrice,
            currentTickIndex: initTick,
            feeGrowthGlobalX: 0,
            feeGrowthGlobalY: 0,
            feeProtocolTokenX: 0,
            feeProtocolTokenY: 0,
            startTimestamp: currentTimestamp,
            lastTimestamp: currentTimestamp,
            feeReceiver: feeReceiver
        }
        let key = toBytes(poolKey)
        pools.insert!(originalCaller, key, state)
    }

    fn containsPool(poolKey: PoolKey) -> Bool {
        let key = toBytes(poolKey)
        return pools.contains!(key)
    }

    fn setLastTimestamp(poolKey: PoolKey, timestamp: U256) -> () {
        let key = toBytes(poolKey)
        let mut state = pools[key]
        state.lastTimestamp = timestamp
        pools[key] = state
    }
    
    fn setFeeReceiver(poolKey: PoolKey, newReceiver: Address) -> () {
        let key = toBytes(poolKey)
        let mut state = pools[key]
        state.feeReceiver = newReceiver
        pools[key] = state
    }

    fn wrappedGetPool(poolKey: PoolKey) -> (Bool, Pool) {
        let key = toBytes(poolKey)
        if(containsPool(poolKey)) {
            return true, pools[key]
        } else {   
            return false,
            Pool {
                poolKey: PoolKey {
                    tokenX: addressToContractId!(nullContractAddress!()),
                    tokenY: addressToContractId!(nullContractAddress!()),
                    feeTier: FeeTier {
                        fee: 0,
                        tickSpacing: 0
                    }
                },
                liquidity: 0,
                sqrtPrice: 0,
                currentTickIndex: 0i,
                feeGrowthGlobalX: 0,
                feeGrowthGlobalY: 0,
                feeProtocolTokenX: 0,
                feeProtocolTokenY: 0,
                startTimestamp: 0,
                lastTimestamp: 0,
                feeReceiver: nullContractAddress!()
            }
        } 
    }

    fn wrappedUpdateLiquidity(poolKey: PoolKey, liquidityDelta: U256, liquiditySign: Bool, upperTick: I256, lowerTick: I256) -> (U256, U256) {
        let key = toBytes(poolKey)
        let (x, y, pool) = updateLiquidity(pools[key], liquidityDelta, liquiditySign, upperTick, lowerTick)
        pools[key] = pool
        return x, y
    }

    fn wrappedGetProtocolFee(poolKey: PoolKey) -> (U256, U256) {
        let key = toBytes(poolKey)
        let (feeProtocolTokenX, feeProtocolTokenY, pool) = getAndUpdateProtocolFee(pools[key])
        pools[key] = pool
        return feeProtocolTokenX, feeProtocolTokenY
    }
}