Contract Ticks(
    tickTemplateContractId: ByteVec,
    mut invariantId: Address,
    mut swapUtilsId: Address,
    mut positionsId: Address,
    mut areAdminsSet: Bool
) {
    enum TicksError {
        TickAlreadyExist = 700
        NotAdmin = 701
        AdminsAreSet = 702
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn setAdmins(invariant: Address, positions: Address, swapUtils: Address) -> () {
        assert!(!areAdminsSet, TicksError.AdminsAreSet)
        invariantId = invariant
        positionsId = positions
        swapUtilsId = swapUtils
        areAdminsSet = true
    }

    @using(preapprovedAssets = true)
    pub fn add(
        caller: Address,
        poolKey: ByteVec,
        index: I256,
        sign: Bool,
        liquidityChange: U256,
        liquidityGross: U256,
        sqrtPrice: U256,
        feeGrowthOutsideX: U256,
        feeGrowthOutsideY: U256,
        secondsOutside: U256
    ) -> () {
        let callerId = callerAddress!()
        checkCaller!((callerId == invariantId || callerId == swapUtilsId || callerId == positionsId) && areAdminsSet, TicksError.NotAdmin)

        let path = poolKey ++ toByteVec!(index)
        assert!(!contractExists!(subContractId!(path)), TicksError.TickAlreadyExist)

        let (encodedImmFields, encodedMutFields) = Tick.encodeFields!(
            selfAddress!(),
            sign,
            liquidityChange,
            liquidityGross,
            sqrtPrice,
            feeGrowthOutsideX,
            feeGrowthOutsideY,
            secondsOutside
        )
        copyCreateSubContract!{caller -> ALPH: 1 alph}(
            path,
            tickTemplateContractId,
            encodedImmFields,
            encodedMutFields
        )
    }

    pub fn exist(
        poolKey: ByteVec,
        index: I256
    ) -> Bool {
        return contractExists!(subContractId!(poolKey ++ toByteVec!(index)))
    }

    pub fn updateTick(poolKey: ByteVec, index: I256, liquidityDelta: U256, maxLiquidityPerTick: U256, isUpper: Bool, isDeposit: Bool) -> () {
        let callerId = callerAddress!()
        checkCaller!((callerId == invariantId || callerId == swapUtilsId || callerId == positionsId) && areAdminsSet, TicksError.NotAdmin)

        Tick(subContractId!(poolKey ++ toByteVec!(index))).updateTick(liquidityDelta, maxLiquidityPerTick, isUpper, isDeposit)
    }

    pub fn getFeeGrowthOutside(poolKey: ByteVec, index: I256) -> (U256, U256) {
        let contract = Tick(subContractId!(poolKey ++ toByteVec!(index)))
        return contract.getFeeGrowthOutsideX(), contract.getFeeGrowthOutsideY()
    }

    pub fn getLiquidityChange(poolKey: ByteVec, index: I256) -> U256 {
        return Tick(subContractId!(poolKey ++ toByteVec!(index))).getLiquidityChange()
    }

    pub fn getLiquidityGross(poolKey: ByteVec, index: I256) -> U256 {
        return Tick(subContractId!(poolKey ++ toByteVec!(index))).getLiquidityGross()
    }

    pub fn wrappedCross(poolKey: ByteVec, index: I256, feeGrowthGlobalX: U256, feeGrowthGlobalY: U256, currentTick: I256) -> (Bool, U256) {
        let callerId = callerAddress!()
        checkCaller!((callerId == invariantId || callerId == swapUtilsId || callerId == positionsId) && areAdminsSet, TicksError.NotAdmin)

        return Tick(subContractId!(poolKey ++ toByteVec!(index))).cross(feeGrowthGlobalX, feeGrowthGlobalY, currentTick, index)
    }

    pub fn get(poolKey: ByteVec, index: I256) -> (Bool, Bool, U256, U256, U256, U256, U256, U256) {
        let subContractId = subContractId!(poolKey ++ toByteVec!(index))

        if (!contractExists!(subContractId)) {
            return false, false, 0, 0, 0, 0, 0, 0
        } else {
            return true, Tick(subContractId).get()
        }
    }
}