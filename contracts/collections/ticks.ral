Contract Ticks(admin: Address, tickTemplateContractId: ByteVec, clammContractId: ByteVec) {
    enum TicksError {
        NotAdmin = 1000
        TickNotFound = 1001
        TickAlreadyExist = 1002
    }

    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn add(
        caller: Address,
        poolKey: ByteVec,
        initTick: I256,
        sign: Bool
    ) -> () {
        assert!(callerAddress!() == admin, TicksError.NotAdmin)

        let (doesExist, isTickInitialized) = exist(poolKey, initTick) 

        assert!(!doesExist && !isTickInitialized, TicksError.TickAlreadyExist)
        
        let (encodedImmFields, encodedMutFields) = Tick.encodeFields!(selfAddress!(), initTick, sign, 0, 0, CLAMM(clammContractId).sqrtPriceFromTick(initTick), 0, 0, 0, true)
        copyCreateSubContract!{caller -> ALPH: 1 alph}(
            poolKey ++ toByteVec!(initTick),
            tickTemplateContractId,
            encodedImmFields,
            encodedMutFields
        )   
        return
    }

    pub fn exist(
        poolKey: ByteVec,
        index: I256
    ) -> (Bool, Bool) {
        if(contractExists!(subContractId!(poolKey ++ toByteVec!(index)))) {
            let contract = Tick(subContractId!(poolKey ++ toByteVec!(index)))
            return true, contract.getIsInitialized()
        }
        return false, false
    }

    pub fn get(poolKey: ByteVec, index: I256) -> ByteVec {
        return poolKey ++ toByteVec!(index)
    }


    @using(checkExternalCaller = false)
    pub fn reinitializeTick(
        poolKey: ByteVec,
        index: I256,
        poolCurrentIndex: I256,
        poolFeeGrowthGlobalX: U256,
        poolFeeGrowthGlobalY: U256,
        poolTimestamp: U256,
        currentTimestamp: U256
    ) -> () {
        assert!(callerAddress!() == admin, TicksError.NotAdmin)
        let (doesExist, isTickInitialized) = exist(poolKey, index)
        assert!(doesExist && !isTickInitialized, TicksError.TickNotFound)
        let contract = Tick(subContractId!(poolKey ++ toByteVec!(index)))
        contract.reinitializeTick(index, poolCurrentIndex, poolFeeGrowthGlobalX, poolFeeGrowthGlobalY, poolTimestamp, currentTimestamp)
        return
    }

    @using(checkExternalCaller = false)
    pub fn deinitializeTick(
        poolKey: ByteVec,
        index: I256
    ) -> () {
        assert!(callerAddress!() == admin, TicksError.NotAdmin)
        let (doesExist, isTickInitialized) = exist(poolKey, index)
        assert!(doesExist && isTickInitialized, TicksError.TickNotFound)
        let contract = Tick(subContractId!(poolKey ++ toByteVec!(index)))
        contract.deinitializeTick()
        return
    }

}