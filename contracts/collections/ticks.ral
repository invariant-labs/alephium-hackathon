Contract Ticks(admin: Address, tickTemplateContractId: ByteVec, clammContractId: ByteVec) {
    enum TicksError {
        NotAdmin = 1000
        TickNotFound = 1001
        TickAlreadyExist = 1002
    }

    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn add(
        caller: Address,
        poolKey: ByteVec,
        initTick: I256,
        sign: Bool
    ) -> () {
        assert!(callerAddress!() == admin, TicksError.NotAdmin)

        let (doesExist, isTickInitialized) = exist(poolKey, initTick) 

        assert!(!doesExist && !isTickInitialized, TicksError.TickAlreadyExist)
        
        if(doesExist && !isTickInitialized) {
            let _ = Tick(poolKey ++ toByteVec!(initTick))
            // contract.reinitializeTick()
            return
        } else {
            let (encodedImmFields, encodedMutFields) = Tick.encodeFields!(selfAddress!(), initTick, sign, 0, 0, CLAMM(clammContractId).sqrtPriceFromTick(initTick), 0, 0, 0, true)
            copyCreateSubContract!{caller -> ALPH: 1 alph}(
                poolKey ++ toByteVec!(initTick),
                tickTemplateContractId,
                encodedImmFields,
                encodedMutFields
            )   
            return
        }
    }

    pub fn exist(
        poolKey: ByteVec,
        index: I256
    ) -> (Bool, Bool) {
        if(contractExists!(subContractId!(poolKey ++ toByteVec!(index)))) {
            let contract = Tick(subContractId!(poolKey ++ toByteVec!(index)))
            return true, contract.getIsInitialized()
        }
        return false, false
    }

    @using(checkExternalCaller = false)
    pub fn deinitializeTick(
        poolKey: ByteVec,
        index: I256
    ) -> () {
        assert!(callerAddress!() == admin, TicksError.NotAdmin)
        let (doesExist, isTickInitialized) = exist(poolKey, index)
        assert!(doesExist && isTickInitialized, TicksError.TickNotFound)
        let contract = Tick(subContractId!(poolKey ++ toByteVec!(index)))
        contract.deinitializeTick()
        return
    }

    pub fn get(poolKey: ByteVec, index: I256) -> (Bool, ByteVec) {
        let mut tick = b``

        let subContractId = subContractId!(poolKey ++ toByteVec!(index))

        if (!contractExists!(subContractId)) {
            return false, b``
        }

        let contract = Tick(subContractId)
        tick = tick 
        ++ toByteVec!(contract.getTickSign()) ++ b`break` 
        ++ toByteVec!(contract.getLiquidityChange()) ++ b`break` 
        ++ toByteVec!(contract.getLiquidityGross()) ++ b`break` 
        ++ toByteVec!(contract.getTickSqrtPrice()) ++ b`break`
        ++ toByteVec!(contract.getTickFeeGrowthOutsideX()) ++ b`break`
        ++ toByteVec!(contract.getTickFeeGrowthOutsideY()) ++ b`break`
        ++ toByteVec!(contract.getTickSecondsOutside())

        return true, tick
    }
}