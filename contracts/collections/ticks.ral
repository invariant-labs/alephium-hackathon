Contract Ticks(admin: Address, tickTemplateContractId: ByteVec, clammContractId: ByteVec) {
    enum TicksError {
        NotAdmin = 1000
        TickNotFound = 1001
        TickAlreadyExist = 1002
    }

    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn add(
        caller: Address,
        poolKey: ByteVec,
        initTick: I256,
        sign: Bool
    ) -> () {
        assert!(callerAddress!() == admin, TicksError.NotAdmin)

        let (doesExist, isTickInitialized) = exist(poolKey, initTick) 

        assert!(!doesExist && !isTickInitialized, TicksError.TickAlreadyExist)
        
        let (encodedImmFields, encodedMutFields) = Tick.encodeFields!(selfAddress!(), initTick, sign, 0, 0, CLAMM(clammContractId).sqrtPriceFromTick(initTick), 0, 0, 0, true)
        copyCreateSubContract!{caller -> ALPH: 1 alph}(
            poolKey ++ toByteVec!(initTick),
            tickTemplateContractId,
            encodedImmFields,
            encodedMutFields
        )   
        return
    }

    pub fn exist(
        poolKey: ByteVec,
        index: I256
    ) -> (Bool, Bool) {
        if(contractExists!(subContractId!(poolKey ++ toByteVec!(index)))) {
            let contract = Tick(subContractId!(poolKey ++ toByteVec!(index)))
            return true, contract.getIsInitialized()
        }
        return false, false
    }

    pub fn getId(poolKey: ByteVec, index: I256) -> ByteVec {
        return poolKey ++ toByteVec!(index)
    }


    @using(checkExternalCaller = false)
    pub fn reinitializeTick(
        poolKey: ByteVec,
        index: I256,
        poolCurrentIndex: I256,
        poolFeeGrowthGlobalX: U256,
        poolFeeGrowthGlobalY: U256,
        poolTimestamp: U256,
        currentTimestamp: U256
    ) -> () {
        assert!(callerAddress!() == admin, TicksError.NotAdmin)
        let (doesExist, isTickInitialized) = exist(poolKey, index)
        assert!(doesExist && !isTickInitialized, TicksError.TickNotFound)
        let contract = Tick(subContractId!(poolKey ++ toByteVec!(index)))
        contract.reinitializeTick(index, poolCurrentIndex, poolFeeGrowthGlobalX, poolFeeGrowthGlobalY, poolTimestamp, currentTimestamp)
        return
    }

    @using(checkExternalCaller = false)
    pub fn deinitializeTick(
        poolKey: ByteVec,
        index: I256
    ) -> () {
        assert!(callerAddress!() == admin, TicksError.NotAdmin)
        let (doesExist, isTickInitialized) = exist(poolKey, index)
        assert!(doesExist && isTickInitialized, TicksError.TickNotFound)
        let contract = Tick(subContractId!(poolKey ++ toByteVec!(index)))
        contract.deinitializeTick()
        return
    }

    @using(checkExternalCaller = false)
    pub fn wrappedUpdateTick(contractId: ByteVec, liquidityDelta: U256, maxLiquidityPerTick: U256, isUpper: Bool, add: Bool) -> () {
        Tick(subContractId!(contractId)).updateTick(liquidityDelta, maxLiquidityPerTick, isUpper, add)
    }

    pub fn getModifyParams(contractId: ByteVec) -> (I256, U256, U256) {
        let contract = Tick(subContractId!(contractId))
        return contract.getIdx(), contract.getTickFeeGrowthOutsideX(), contract.getTickFeeGrowthOutsideY()
    }

    pub fn get(poolKey: ByteVec, index: I256) -> (Bool, ByteVec) {
        let mut tickBytes = b``

        let subContractId = subContractId!(poolKey ++ toByteVec!(index))

        if (!contractExists!(subContractId)) {
            return false, b``
        }

        let contract = Tick(subContractId)
        tickBytes = tickBytes
        ++ toByteVec!(contract.getTickSign()) ++ b`break` 
        ++ toByteVec!(contract.getLiquidityChange()) ++ b`break` 
        ++ toByteVec!(contract.getLiquidityGross()) ++ b`break` 
        ++ toByteVec!(contract.getTickSqrtPrice()) ++ b`break`
        ++ toByteVec!(contract.getTickFeeGrowthOutsideX()) ++ b`break`
        ++ toByteVec!(contract.getTickFeeGrowthOutsideY()) ++ b`break`
        ++ toByteVec!(contract.getTickSecondsOutside())

        return true, tickBytes
    }
}