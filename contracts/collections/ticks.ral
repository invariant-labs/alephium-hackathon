Contract Ticks(
    mut invariantId: Address,
    mut areAdminsSet: Bool
) extends TickHelper() {
    // Key: poolKey ++ index
    mapping[ByteVec, Tick] ticks

    enum TicksError {
        NotAdmin = 700
        AdminsAreSet = 701
        TickAlreadyExist = 702
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn setAdmins(invariant: Address) -> () {
        assert!(!areAdminsSet, TicksError.AdminsAreSet)
        invariantId = invariant
        areAdminsSet = true
    }

    @using(preapprovedAssets = true)
    pub fn add(
        originalCaller: Address,
        poolKey: ByteVec,
        index: I256,
        sign: Bool,
        liquidityChange: U256,
        liquidityGross: U256,
        sqrtPrice: U256,
        feeGrowthOutsideX: U256,
        feeGrowthOutsideY: U256,
        secondsOutside: U256
    ) -> () {
        let caller = callerAddress!()
        checkCaller!((caller == invariantId) && areAdminsSet, TicksError.NotAdmin)

        let key = poolKey ++ toByteVec!(index)
        assert!(!contains(poolKey, index), TicksError.TickAlreadyExist)

        let state = Tick {
            sign: sign,
            liquidityChange: liquidityChange,
            liquidityGross: liquidityGross,
            sqrtPrice: sqrtPrice,
            feeGrowthOutsideX: feeGrowthOutsideX,
            feeGrowthOutsideY: feeGrowthOutsideY,
            secondsOutside: secondsOutside
        }

        ticks.insert!(originalCaller, key, state)
    }

    pub fn contains(
        poolKey: ByteVec,
        index: I256
    ) -> Bool {
        let key = poolKey ++ toByteVec!(index)
        return ticks.contains!(key)
    }

    pub fn wrappedUpdateTick(poolKey: ByteVec, index: I256, liquidityDelta: U256, maxLiquidityPerTick: U256, isUpper: Bool, isDeposit: Bool) -> () {
        let caller = callerAddress!()
        checkCaller!((caller == invariantId) && areAdminsSet, TicksError.NotAdmin)
        
        let key = poolKey ++ toByteVec!(index)
        let tick = ticks[key]
        let updatedTick = updateTick(tick, liquidityDelta, maxLiquidityPerTick, isUpper, isDeposit)
        ticks[key] = updatedTick
    }

    pub fn getFeeGrowthOutside(poolKey: ByteVec, index: I256) -> (U256, U256) {
        let key = poolKey ++ toByteVec!(index)
        let tick = ticks[key]
        return tick.feeGrowthOutsideX, tick.feeGrowthOutsideY
    }

    pub fn getLiquidityChange(poolKey: ByteVec, index: I256) -> U256 {
        let key = poolKey ++ toByteVec!(index)
        let tick = ticks[key]
        return tick.liquidityChange
    }

    pub fn getLiquidityGross(poolKey: ByteVec, index: I256) -> U256 {
        let key = poolKey ++ toByteVec!(index)
        let tick = ticks[key]
        return tick.liquidityGross
    }

    pub fn get(poolKey: ByteVec, index: I256) -> (Bool, Tick) {
        let key = poolKey ++ toByteVec!(index)
        if (contains(poolKey, index)) {
            return true, ticks[key]
        } else {
            return false, Tick {
                sign: false,
                liquidityChange: 0,
                liquidityGross: 0,
                sqrtPrice: 0,
                feeGrowthOutsideX: 0,
                feeGrowthOutsideY: 0,
                secondsOutside: 0
            }
        }
    }

    pub fn wrappedCross(poolKey: ByteVec, index: I256, feeGrowthGlobalX: U256, feeGrowthGlobalY: U256, currentTick: I256) -> (Bool, U256) {
        let caller = callerAddress!()
        checkCaller!((caller == invariantId) && areAdminsSet, TicksError.NotAdmin)
        let key = poolKey ++ toByteVec!(index)
        let tick = ticks[key]
        let (addLiquidity, crossedTick) = cross(tick, feeGrowthGlobalX, feeGrowthGlobalY, currentTick, index)
        ticks[key] = crossedTick
        return addLiquidity, crossedTick.liquidityChange
    }
}