Contract Tick(
    mut tickSign: Bool,
    mut tickLiquidityChange: U256,
    mut tickLiquidityGross: U256,
    tickSqrtPrice: U256,
    mut tickFeeGrowthOutsideX: U256,
    mut tickFeeGrowthOutsideY: U256,
    // Remove
    tickSecondsOutside: U256
) extends Decimal() {
    enum TickError {
        InvalidTickLiquidity = 1000
    }

    pub fn getSign() -> Bool {
        return tickSign
    }

    pub fn getLiquidityChange() -> U256 {
        return tickLiquidityChange
    }

    pub fn getLiquidityGross() -> U256 {
        return tickLiquidityGross
    }

    pub fn getSqrtPrice() -> U256 {
        return tickSqrtPrice
    }

    pub fn getFeeGrowthOutsideX() -> U256 {
        return tickFeeGrowthOutsideX
    }

    pub fn getFeeGrowthOutsideY() -> U256 {
        return tickFeeGrowthOutsideY
    }

    pub fn getSecondsOutside() -> U256 {
        return tickSecondsOutside
    }

    pub fn get() -> (Bool, U256, U256, U256, U256, U256, U256) {
        return tickSign, tickLiquidityChange, tickLiquidityGross, tickSqrtPrice, tickFeeGrowthOutsideX, tickFeeGrowthOutsideY, tickSecondsOutside
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn updateTick(liquidityDelta: U256, maxLiquidityPerTick: U256, isUpper: Bool, isDeposit: Bool) -> () {
        tickLiquidityGross = calculateNewLiquidityGross(isDeposit, liquidityDelta, maxLiquidityPerTick)
        let updateLiquiditySign = isDeposit && !isUpper || !isDeposit && isUpper
        updateLiquidityChange(liquidityDelta, updateLiquiditySign)
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn cross(feeGrowthGlobalX: U256, feeGrowthGlobalY: U256, currentTick: I256, index: I256) -> (Bool, U256) {
        tickFeeGrowthOutsideX = wrappingSub(feeGrowthGlobalX, tickFeeGrowthOutsideX)
        tickFeeGrowthOutsideY = wrappingSub(feeGrowthGlobalY, tickFeeGrowthOutsideY)

        let isBelowCurrent = currentTick >= index

        return (isBelowCurrent && !tickSign || !isBelowCurrent && tickSign), getLiquidityChange()
    }

    @using(updateFields = true, checkExternalCaller = false)
    fn updateLiquidityChange(liquidityDelta: U256, add: Bool) -> () {
        if (tickSign && !add || !tickSign && add) {
            if (tickLiquidityChange > liquidityDelta) {
                tickLiquidityChange = tickLiquidityChange - liquidityDelta
            } else {
                tickLiquidityChange = liquidityDelta - tickLiquidityChange
                tickSign = !tickSign
            }
        } else {
            tickLiquidityChange = tickLiquidityChange + liquidityDelta
        }
        return
    }

    fn calculateNewLiquidityGross(sign: Bool, liquidityDelta: U256, maxLiquidityPerTick: U256) -> U256 {
        assert!(sign || tickLiquidityGross >= liquidityDelta, TickError.InvalidTickLiquidity)

        let mut newLiquidity = 0
        if (sign) {
            newLiquidity = tickLiquidityGross + liquidityDelta
        } else {
            newLiquidity = tickLiquidityGross - liquidityDelta
        }

        assert!(!sign || newLiquidity < maxLiquidityPerTick, TickError.InvalidTickLiquidity)

        return newLiquidity
    }
}