struct Position {
    mut poolKey: PoolKey,
    mut liquidity: U256,
    mut lowerTickIndex: I256,
    mut upperTickIndex: I256,
    mut feeGrowthInsideX: U256,
    mut feeGrowthInsideY: U256,
    mut lastBlockNumber: U256,
    mut tokensOwedX: U256,
    mut tokensOwedY: U256,
    mut owner: Address
}

Abstract Contract PositionHelper(clamm: CLAMM) extends Decimal() {
    @using(updateFields = false)
    fn modify(
        mut position: Position,
        mut pool: Pool,
        lowerTick: Tick,
        upperTick: Tick,
        liquidityDelta: U256,
        add: Bool,
        currentTimestamp: U256
    ) -> (U256, U256, Position, Bool, Bool) {
        pool.lastTimestamp = currentTimestamp

        let maxLiquidityPerTick = clamm.calculateMaxLiquidityPerTick(pool.poolKey.feeTier.tickSpacing)

        // Might add returning if tick is empty for deinitialization
        let isLowerEmpty = updateTick(pool.poolKey, lowerTick, liquidityDelta, maxLiquidityPerTick, false, add)
        let isUpperEmpty = updateTick(pool.poolKey, upperTick, liquidityDelta, maxLiquidityPerTick, true, add)

        let (feeGrowthInsideX, feeGrowthInsideY) = clamm.calculateFeeGrowthInside(
            lowerTick.index,
            lowerTick.feeGrowthOutsideX,
            lowerTick.feeGrowthOutsideY,
            upperTick.index,
            upperTick.feeGrowthOutsideX,
            upperTick.feeGrowthOutsideY,
            pool.currentTickIndex,
            pool.feeGrowthGlobalX,
            pool.feeGrowthGlobalY
        )
        
        
        position = update(position, add, liquidityDelta, feeGrowthInsideX, feeGrowthInsideY)

        let (x, y, uPool) = updatePoolLiquidity(pool, liquidityDelta, add, upperTick.index, lowerTick.index)
        rewritePool(uPool)
        
        return x, y, position, isLowerEmpty, isUpperEmpty
    }

    fn update(
        mut position: Position,
        sign: Bool,
        liquidityDelta: U256,
        feeGrowthInsideX: U256,
        feeGrowthInsideY: U256
    ) -> Position {
        let tokensOwedX = clamm.toFee(wrappingSub(feeGrowthInsideX, position.feeGrowthInsideX), position.liquidity)
        let tokensOwedY = clamm.toFee(wrappingSub(feeGrowthInsideY, position.feeGrowthInsideY), position.liquidity)

        position.liquidity = calculateNewLiquidity(position.liquidity, sign, liquidityDelta)
        position.feeGrowthInsideX = feeGrowthInsideX
        position.feeGrowthInsideY = feeGrowthInsideY

        position.tokensOwedX = tokensOwedX
        position.tokensOwedY = tokensOwedY
        return position
    }

    fn calculateNewLiquidity(
        currentPositionLiquidity: U256,
        sign: Bool,
        liquidityDelta: U256
    ) -> U256 {
        if (sign) {
            return currentPositionLiquidity + liquidityDelta
        } else {
            assert!(currentPositionLiquidity >= liquidityDelta, InvariantError.InsufficientLiquidity)
            return currentPositionLiquidity - liquidityDelta
        }
    }

    fn serializePosition(position: Position) -> ByteVec {
        return position.poolKey.tokenX ++ b`break`
        ++ position.poolKey.tokenY ++ b`break`
        ++ toByteVec!(position.poolKey.feeTier.fee) ++ b`break`
        ++ toByteVec!(position.poolKey.feeTier.tickSpacing) ++ b`break`
        ++ toByteVec!(position.liquidity) ++ b`break`
        ++ toByteVec!(position.lowerTickIndex) ++ b`break`
        ++ toByteVec!(position.upperTickIndex) ++ b`break`
        ++ toByteVec!(position.feeGrowthInsideX) ++ b`break`
        ++ toByteVec!(position.feeGrowthInsideY) ++ b`break`
        ++ toByteVec!(position.lastBlockNumber) ++ b`break`
        ++ toByteVec!(position.tokensOwedX) ++ b`break`
        ++ toByteVec!(position.tokensOwedY) ++ b`break`
        ++ toByteVec!(position.owner) ++ b`break`
    }
}