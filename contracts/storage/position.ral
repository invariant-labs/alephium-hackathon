Contract Position(
    posPoolKey: ByteVec,
    mut posLiquidity: U256,
    posLowerTickIndex: I256,
    posUpperTickIndex: I256,
    mut posFeeGrowthInsideX: U256,
    mut posFeeGrowthInsideY: U256,
    posLastBlockNumber: U256,
    mut posTokensOwedX: U256,
    mut posTokensOwedY: U256,
    mut posOwner: Address,
    mut posIsActive: Bool
) extends Decimal() {
    enum PositionError {
        InsufficientLiquidity = 700
        EmptyPositionPokes = 701
    }

    pub fn getPoolKey() -> ByteVec {
        return posPoolKey
    }

    pub fn getLiquidity() -> U256 {
        return posLiquidity
    }

    pub fn getLowerTickIndex() -> I256 {
        return posLowerTickIndex
    }

    pub fn getUpperTickIndex() -> I256 {
        return posUpperTickIndex
    }

    pub fn getFeeGrowthInsideX() -> U256 {
        return posFeeGrowthInsideX
    }

    pub fn getFeeGrowthInsideY() -> U256 {
        return posFeeGrowthInsideY
    }

    pub fn getLastBlockNumber() -> U256 {
        return posLastBlockNumber
    }

    pub fn getTokensOwedX() -> U256 {
        return posTokensOwedX
    }

    pub fn getTokensOwedY() -> U256 {
        return posTokensOwedY
    }

    pub fn getOwner() -> Address {
        return posOwner
    }

    pub fn get() -> (U256, I256, I256, U256, U256, U256, U256, U256) {
        return posLiquidity, posLowerTickIndex, posUpperTickIndex, posFeeGrowthInsideX, posFeeGrowthInsideY, posLastBlockNumber, posTokensOwedX, posTokensOwedY
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn setTokensOwedX(tokensOwedX: U256) -> () {
        posTokensOwedX = tokensOwedX
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn setTokensOwedY(tokensOwedY: U256) -> () {
        posTokensOwedY = tokensOwedY
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn setOwner(owner: Address) -> () {
        posOwner = owner
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn setIsActive(isActive: Bool) -> () {
        posIsActive = isActive
    }

    @using(updateFields = false, checkExternalCaller = false)
    pub fn modify(
        poolsContractId: ByteVec,
        ticksContractId: ByteVec,
        clammContractId: ByteVec,
        poolKey: ByteVec,
        upperTick: I256,
        lowerTick: I256,
        liquidityDelta: U256,
        add: Bool,
        currentTimestamp: U256,
        tickSpacing: U256
    ) -> (U256, U256) {
        let pools = Pools(poolsContractId)
        pools.setLastTimestamp(poolKey, currentTimestamp)

        let maxLiquidityPerTick = CLAMM(clammContractId).calculateMaxLiquidityPerTick(tickSpacing)

        let ticks = Ticks(ticksContractId)

        ticks.updateTick(poolKey, lowerTick, liquidityDelta, maxLiquidityPerTick, false, add)
        ticks.updateTick(poolKey, upperTick, liquidityDelta, maxLiquidityPerTick, true, add)

        let (lowerTickFeeGrowthOutsideX, lowerTickFeeGrowthOutsideY) = ticks.getFeeGrowthOutside(poolKey, lowerTick)
        let (upperTickFeeGrowthOutsideX, upperTickFeeGrowthOutsideY) = ticks.getFeeGrowthOutside(poolKey, upperTick)
        let poolCurrentTickIndex = pools.getCurrentTickIndex(poolKey)
        let (poolFeeGrowthGlobalX, poolFeeGrowthGlobalY) = pools.getFeeGrowthGlobal(poolKey)

        let (feeGrowthInsideX, feeGrowthInsideY) = CLAMM(clammContractId).calculateFeeGrowthInside(
            lowerTick,
            lowerTickFeeGrowthOutsideX,
            lowerTickFeeGrowthOutsideY,
            upperTick,
            upperTickFeeGrowthOutsideX,
            upperTickFeeGrowthOutsideY,
            poolCurrentTickIndex,
            poolFeeGrowthGlobalX,
            poolFeeGrowthGlobalY
        )

        update(add, liquidityDelta, feeGrowthInsideX, feeGrowthInsideY)

        return pools.updateLiquidity(poolKey, liquidityDelta, add, upperTick, lowerTick)
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn update(
        sign: Bool,
        liquidityDelta: U256,
        feeGrowthInsideX: U256,
        feeGrowthInsideY: U256
    ) -> () {
        assert!(liquidityDelta != 0 || posLiquidity != 0, PositionError.EmptyPositionPokes)

        let tokensOwedX = toFee(wrappingSub(feeGrowthInsideX, posFeeGrowthInsideX), posLiquidity)
        let tokensOwedY = toFee(wrappingSub(feeGrowthInsideY, posFeeGrowthInsideY), posLiquidity)

        posLiquidity = calculateNewLiquidity(sign, liquidityDelta)
        posFeeGrowthInsideX = feeGrowthInsideX
        posFeeGrowthInsideY = feeGrowthInsideY

        posTokensOwedX = tokensOwedX
        posTokensOwedY = tokensOwedY
    }

    pub fn calculateNewLiquidity(
        sign: Bool,
        liquidityDelta: U256
    ) -> U256 {
        assert!(sign || posLiquidity >= liquidityDelta, PositionError.InsufficientLiquidity)

        if (sign) {
            return posLiquidity + liquidityDelta
        } else {
            return posLiquidity - liquidityDelta
        }
    }
}