Contract Position(
    admin: Address,
    posPoolKey: ByteVec,
    mut posLiquidity: U256,
    posLowerTickIndex: I256,
    posUpperTickIndex: I256,
    mut posFeeGrowthInsideX: U256,
    mut posFeeGrowthInsideY: U256,
    posLastBlockNumber: U256,
    mut posTokensOwedX: U256,
    mut posTokensOwedY: U256,
    mut posOwner: Address,
    mut posIsActive: Bool
) extends Decimal() {
    enum PositionError {
        NotAdmin = 900
        InsufficientLiquidity = 901
        EmptyPositionPokes = 902
    }

    pub fn getPoolKey() -> ByteVec {
        return posPoolKey
    }

    pub fn getLiquidity() -> U256 {
        return posLiquidity
    }

    pub fn getLowerTickIndex() -> I256 {
        return posLowerTickIndex
    }

    pub fn getUpperTickIndex() -> I256 {
        return posUpperTickIndex
    }

    pub fn getFeeGrowthInsideX() -> U256 {
        return posFeeGrowthInsideX
    }

    pub fn getFeeGrowthInsideY() -> U256 {
        return posFeeGrowthInsideY
    }

    pub fn getLastBlockNumber() -> U256 {
        return posLastBlockNumber
    }

    pub fn getTokensOwedX() -> U256 {
        return posTokensOwedX
    }

    pub fn getTokensOwedY() -> U256 {
        return posTokensOwedY
    }

    pub fn getOwner() -> Address {
        return posOwner
    }

    pub fn get() -> (U256, I256, I256, U256, U256, U256, U256, U256, Address) {
        return posLiquidity, posLowerTickIndex, posUpperTickIndex, posFeeGrowthInsideX, posFeeGrowthInsideY, posLastBlockNumber, posTokensOwedX, posTokensOwedY, posOwner
    }

    @using(updateFields = true)
    pub fn setTokensOwedX(tokensOwedX: U256) -> () {
        checkCaller!(callerAddress!() == admin, PositionError.NotAdmin)
        posTokensOwedX = tokensOwedX
    }

    @using(updateFields = true)
    pub fn setTokensOwedY(tokensOwedY: U256) -> () {
        checkCaller!(callerAddress!() == admin, PositionError.NotAdmin)
        posTokensOwedY = tokensOwedY
    }

    @using(updateFields = true)
    pub fn setOwner(owner: Address) -> () {
        checkCaller!(callerAddress!() == admin, PositionError.NotAdmin)
        posOwner = owner
    }

    @using(updateFields = true)
    pub fn setIsActive(isActive: Bool) -> () {
        checkCaller!(callerAddress!() == admin, PositionError.NotAdmin)
        posIsActive = isActive
    }

    @using(updateFields = false)
    pub fn modify(
        clamm: CLAMM,
        upperTick: I256,
        upperTickFeeGrowthOutsideX: U256,
        upperTickFeeGrowthOutsideY: U256,
        lowerTick: I256,
        lowerTickFeeGrowthOutsideX: U256,
        lowerTickFeeGrowthOutsideY: U256,
        poolCurrentTickIndex: I256,
        poolFeeGrowthGlobalX: U256,
        poolFeeGrowthGlobalY: U256,
        liquidityDelta: U256,
        add: Bool
    ) -> () {
        checkCaller!(callerAddress!() == admin, PositionError.NotAdmin)

        let (feeGrowthInsideX, feeGrowthInsideY) = clamm.calculateFeeGrowthInside(
            lowerTick,
            lowerTickFeeGrowthOutsideX,
            lowerTickFeeGrowthOutsideY,
            upperTick,
            upperTickFeeGrowthOutsideX,
            upperTickFeeGrowthOutsideY,
            poolCurrentTickIndex,
            poolFeeGrowthGlobalX,
            poolFeeGrowthGlobalY
        )

        update(add, liquidityDelta, feeGrowthInsideX, feeGrowthInsideY)
    }

    @using(updateFields = true)
    pub fn update(
        sign: Bool,
        liquidityDelta: U256,
        feeGrowthInsideX: U256,
        feeGrowthInsideY: U256
    ) -> () {
        let caller = callerAddress!()
        checkCaller!(caller == admin || caller == selfAddress!(), PositionError.NotAdmin)

        assert!(liquidityDelta != 0 || posLiquidity != 0, PositionError.EmptyPositionPokes)

        let tokensOwedX = toFee(wrappingSub(feeGrowthInsideX, posFeeGrowthInsideX), posLiquidity)
        let tokensOwedY = toFee(wrappingSub(feeGrowthInsideY, posFeeGrowthInsideY), posLiquidity)

        posLiquidity = calculateNewLiquidity(sign, liquidityDelta)
        posFeeGrowthInsideX = feeGrowthInsideX
        posFeeGrowthInsideY = feeGrowthInsideY

        posTokensOwedX = tokensOwedX
        posTokensOwedY = tokensOwedY
    }

    pub fn calculateNewLiquidity(
        sign: Bool,
        liquidityDelta: U256
    ) -> U256 {
        let caller = callerAddress!()
        checkCaller!(caller == admin || caller == selfAddress!(), PositionError.NotAdmin)
        
        assert!(sign || posLiquidity >= liquidityDelta, PositionError.InsufficientLiquidity)

        if (sign) {
            return posLiquidity + liquidityDelta
        } else {
            return posLiquidity - liquidityDelta
        }
    }
}