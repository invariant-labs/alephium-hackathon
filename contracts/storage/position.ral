Contract Position(
    relatedPoolKey: ByteVec,
    mut posLiquidity: U256,
    posLowerTickIndex: I256,
    posUpperTickIndex: I256,
    mut posFeeGrowthInsideX: U256,
    mut posFeeGrowthInsideY: U256,
    lastBlockNumber: U256,
    mut posTokensOwedX: U256,
    mut posTokensOwedY: U256,
    mut isOpen: Bool,
    clammContractId: ByteVec
) extends Decimal() {
    enum PositionError {
        InsufficientLiquidity = 0
        EmptyPositionPokes = 1
    }

    pub fn getRelatedPoolKey() -> ByteVec {
        return relatedPoolKey
    }

    pub fn getPosLiquidity() -> U256 {
        return posLiquidity
    }

    pub fn getPosLowerTickIndex() -> I256 {
        return posLowerTickIndex
    }

    pub fn getPosUpperTickIndex() -> I256 {
        return posUpperTickIndex
    }

    pub fn getPosFeeGrowthInsideX() -> U256 {
        return posFeeGrowthInsideX
    }

    pub fn getPosFeeGrowthInsideY() -> U256 {
        return posFeeGrowthInsideY
    }

    pub fn getLastBlockNumber() -> U256 {
        return lastBlockNumber
    }

    pub fn getPosTokensOwedX() -> U256 {
        return posTokensOwedX
    }

    pub fn getPosTokensOwedY() -> U256 {
        return posTokensOwedY
    }

    pub fn getIsOpen() -> Bool {
        return isOpen
    }


    @using(updateFields = true, checkExternalCaller = false)
    pub fn close() -> () {
        isOpen = false
    }

    @using(updateFields = false, checkExternalCaller = false)
    pub fn modify(
        // lowerTickIndex: I256,
        // lowerTickFeeGrowthOutsideX: U256,
        // lowerTickFeeGrowthOutsideY: U256,
        // upperTickIndex: I256,
        // upperTickFeeGrowthOutsideX: U256,
        // upperTickFeeGrowthOutsideY: U256,
        // poolIndex: I256,
        // poolFeeGrowthGlobalX: U256,
        // poolFeeGrowthGlobalY: U256,
        // add: Bool,
        // liquidityDelta: U256
    ) -> () {
        // let pools = Pools(poolsContractId)
        // let ticks = Ticks(ticksContractId)
        // update pool last timestamp
        // update ticks
        // update pool liquidity
        // pools.wrappedSetLastTimestamp(poolKey, currentTimestamp)

        CLAMM(clammContractId).calculateMaxLiquidityPerTick(1)

        // ticks.wrappedUpdateTick(lowerTickContractId, liquidityDelta, maxLiquidityPerTick, false, add)
        // ticks.wrappedUpdateTick(upperTickContractId, liquidityDelta, maxLiquidityPerTick, true, add)

        // let (lowerTickIndex, lowerTickFeeGrowthOutsideX, lowerTickFeeGrowthOutsideY) = ticks.getModifyParams(lowerTickContractId)
        // let (upperTickIndex, upperTickFeeGrowthOutsideX, upperTickFeeGrowthOutsideY) = ticks.getModifyParams(upperTickContractId)
        // let (poolIndex, poolFeeGrowthGlobalX, poolFeeGrowthGlobalY) = pools.getModifyParams(poolKey)

        // let (feeGrowthInsideX, feeGrowthInsideY) = calculateFeeGrowthInside(
        //     lowerTickIndex,
        //     lowerTickFeeGrowthOutsideX,
        //     lowerTickFeeGrowthOutsideY,
        //     upperTickIndex,
        //     upperTickFeeGrowthOutsideX,
        //     upperTickFeeGrowthOutsideY,
        //     poolIndex,
        //     poolFeeGrowthGlobalX,
        //     poolFeeGrowthGlobalY
        // )

        // updatePos(add, liquidityDelta, feeGrowthInsideX, feeGrowthInsideY)
        // let (x, y) = pools.wrappedUpdateLiquidity(poolKey, liquidityDelta, add, upperTickIndex, lowerTickIndex)
        // return x, y
        return
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn updatePos(
        sign: Bool,
        liquidityDelta: U256,
        feeGrowthInsideX: U256,
        feeGrowthInsideY: U256
    ) -> () {
        assert!(liquidityDelta != 0 || posLiquidity != 0, PositionError.EmptyPositionPokes)

        let tokensOwedX = toFee(wrappingSub(posFeeGrowthInsideX, posFeeGrowthInsideX), posLiquidity)
        let tokensOwedY = toFee(wrappingSub(posFeeGrowthInsideY, posFeeGrowthInsideY), posLiquidity)

        posLiquidity = calculateNewLiquidity(sign, liquidityDelta)
        posFeeGrowthInsideX = feeGrowthInsideX
        posFeeGrowthInsideY = feeGrowthInsideY

        posTokensOwedX = tokensOwedX
        posTokensOwedY = tokensOwedY
        return
    }

    pub fn calculateNewLiquidity(
        sign: Bool,
        liquidityDelta: U256
    ) -> U256 {
        assert!(sign || posLiquidity >= liquidityDelta, PositionError.InsufficientLiquidity)
        if (sign) {
            return posLiquidity + liquidityDelta
        } else {
            return posLiquidity - liquidityDelta
        }
    }

    // @using(updateFields = true, checkExternalCaller = false)
    // pub fn claimFee(
    //     poolContractId: ByteVec,
    //     lowerTickContractId: ByteVec,
    //     upperTickContractId: ByteVec,
    //     currentTimestamp: U256,
    //     tickSpacing: U256
    // ) -> (U256, U256) {
    //     modify(poolContractId, lowerTickContractId, upperTickContractId, 0, true, currentTimestamp, tickSpacing)

    //     let owedX = posTokensOwedX
    //     let owedY = posTokensOwedY

    //     posTokensOwedX = 0
    //     posTokensOwedY = 0

    //     return owedX, owedY
    // }

    // @using(checkExternalCaller = false)
    // pub fn remove(
    //     poolKey: ByteVec,
    //     lowerTickId: ByteVec,
    //     upperTickId: ByteVec,
    //     currentTimestamp: U256,
    //     tickSpacing: U256
    // ) -> (U256,U256,Bool, Bool) {
    //     let liquidityDelta = getPosLiquidity()
    //     let (mut amountX, mut amountY) = modify(poolKey, lowerTickId, upperTickId, liquidityDelta, false, currentTimestamp, tickSpacing)

    //     amountX = amountX + getPosTokensOwedX()
    //     amountY = amountY + getPosTokensOwedY()
    //     let deinitializeLowerTick = Tick(lowerTickId).getLiquidityGross() == 0
    //     let deinitializeUpperTick = Tick(upperTickId).getLiquidityGross() == 0
    //     return amountX, amountY, deinitializeLowerTick, deinitializeUpperTick
    // }
}