Contract Pool(
    poolTokenX: ByteVec,
    poolTokenY: ByteVec,
    poolTickSpacing: U256,
    mut poolLiquidity: U256,
    mut poolCurrentSqrtPrice: U256,
    mut poolCurrentTickIndex: I256,
    mut poolFeeGrowthGlobalX: U256,
    mut poolFeeGrowthGlobalY: U256,
    mut poolFeeProtocolTokenX: U256,
    mut poolFeeProtocolTokenY: U256,
    poolStartTimestamp: U256,
    mut poolLastTimestamp: U256,
    mut poolFeeReceiver: Address,
    clammContractId: ByteVec
) extends Decimal() {
    pub fn getTokenX() -> ByteVec {
        return poolTokenX
    }

    pub fn getTokenY() -> ByteVec {
        return poolTokenY
    }

    pub fn getTickSpacing() -> U256 {
        return poolTickSpacing
    }

    pub fn getPoolLiquidity() -> U256 {
        return poolLiquidity
    }

    pub fn getPoolCurrentSqrtPrice() -> U256 {
        return poolCurrentSqrtPrice
    }

    pub fn getPoolCurrentTickIndex() -> I256 {
        return poolCurrentTickIndex
    }

    pub fn getFeeGrowthGlobalX() -> U256 {
        return poolFeeGrowthGlobalX
    }

    pub fn getFeeGrowthGlobalY() -> U256 {
        return poolFeeGrowthGlobalY
    }

    pub fn getFeeProtocolTokenX() -> U256 {
        return poolFeeProtocolTokenX
    }

    pub fn getFeeProtocolTokenY() -> U256 {
        return poolFeeProtocolTokenY
    }

    pub fn getStartTimestamp() -> U256 {
        return poolStartTimestamp
    }

    pub fn getLastTimestamp() -> U256 {
        return poolLastTimestamp
    }
    
    pub fn getFeeReceiver() -> Address {
        return poolFeeReceiver
    }

    pub fn get() -> (U256, U256, I256, U256, U256, U256, U256, U256, U256, Address) {
        return poolLiquidity, poolCurrentSqrtPrice, poolCurrentTickIndex, poolFeeGrowthGlobalX, poolFeeGrowthGlobalY, poolFeeProtocolTokenX, poolFeeProtocolTokenY, poolStartTimestamp, poolLastTimestamp, poolFeeReceiver
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn setFeeReceiver(recipient: Address) -> () {
        poolFeeReceiver = recipient
    }
    
    @using(updateFields = true, checkExternalCaller = false)
    pub fn setLastTimestamp(timestamp: U256) -> () {
        poolLastTimestamp = timestamp
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn setSqrtPrice(v: U256) -> () {
        poolCurrentSqrtPrice = v
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn setPoolCurrentTickIndex(v: I256) -> () {
        poolCurrentTickIndex = v
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn addFee(amount: U256, inX: Bool, protocolFee: U256) -> () {
        let invariantProtocolFee = mulUp(amount, protocolFee, getPercentageScale())

        let poolFee = amount - invariantProtocolFee

        if (poolFee == 0 && invariantProtocolFee == 0 || getPoolLiquidity() == 0) {
            return
        }

        let feeGrowth = feeGrowthFromFee(getPoolLiquidity(), poolFee)

        if (inX) {
            poolFeeGrowthGlobalX = wrappingAdd(poolFeeGrowthGlobalX, feeGrowth)
            poolFeeProtocolTokenX = poolFeeProtocolTokenX + invariantProtocolFee
        } else {
            poolFeeGrowthGlobalY = wrappingAdd(poolFeeGrowthGlobalY, feeGrowth)
            poolFeeProtocolTokenY = poolFeeProtocolTokenY + invariantProtocolFee
        }
    }
    
    @using(updateFields = true, checkExternalCaller = false)
    pub fn updateLiquidity(liquidityDelta: U256, liquiditySign: Bool, upperTick: I256, lowerTick: I256) -> (U256, U256) {
        let (x, y, updateLiq) = CLAMM(clammContractId).calculateAmountDelta(getPoolCurrentTickIndex(), getPoolCurrentSqrtPrice(), liquidityDelta, liquiditySign, upperTick, lowerTick)
        if (!updateLiq) {
            return x, y
        }

        if (liquiditySign) {
            poolLiquidity = poolLiquidity + liquidityDelta
        } else {
            poolLiquidity = poolLiquidity - liquidityDelta
        }
        return x, y
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn crossTick(
        nextSqrtPrice: U256,
        swapLimit: U256,
        tickIndex: I256,
        mut remainingAmount: U256,
        byAmountIn: Bool,
        xToY: Bool,
        protocolFee: U256,
        fee: U256,
        tickSpacing: U256
    ) -> (U256, U256, Bool) {
        let mut hasCrossed = false
        let mut totalAmount = 0

        if (nextSqrtPrice == swapLimit) {
            let isEnoughToCross = CLAMM(clammContractId).isEnoughToChangePrice(remainingAmount, nextSqrtPrice, getPoolLiquidity(), fee, byAmountIn, xToY)
            if(!xToY || isEnoughToCross) {
                hasCrossed = true
            } else if (remainingAmount != 0) {
                if (byAmountIn) {
                    addFee(remainingAmount, xToY, protocolFee)
                    totalAmount = remainingAmount
                }
                remainingAmount = 0
            } else {
                // placeholder to compile
            }

            if(xToY && isEnoughToCross) {
                poolCurrentTickIndex = tickIndex - toI256!(tickSpacing)
            } else {
                poolCurrentTickIndex = tickIndex
            }
        } else {
            poolCurrentTickIndex = CLAMM(clammContractId).getTickAtSqrtPrice(nextSqrtPrice, tickSpacing)
        }

        return totalAmount, remainingAmount, hasCrossed
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn crossLiquidityUpdate(add: Bool, liquidityDelta: U256) -> () {
        if (add) {
            poolLiquidity = poolLiquidity + liquidityDelta
        } else {
            poolLiquidity = poolLiquidity - liquidityDelta
        }
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn withdrawProtocolFee() -> (U256, U256) {
        let x = poolFeeProtocolTokenX
        let y = poolFeeProtocolTokenY
        poolFeeProtocolTokenX = 0
        poolFeeProtocolTokenY = 0
        return x, y
    }
}