struct Pool {
    mut poolKey: PoolKey,
    mut liquidity: Liquidity,
    mut sqrtPrice: SqrtPrice,
    mut currentTickIndex: I256,
    mut feeGrowthGlobalX: U256,
    mut feeGrowthGlobalY: U256,
    mut feeProtocolTokenX: U256,
    mut feeProtocolTokenY: U256,
    mut startTimestamp: U256,
    mut lastTimestamp: U256,
    mut feeReceiver: Address,
    mut reserveX: ByteVec,
    mut reserveY: ByteVec
}

Abstract Contract PoolHelper(clamm: CLAMM) extends Decimal() {
    fn addFee(mut pool: Pool, amount: U256, inX: Bool, protocolFee: U256) -> Pool {
        let invariantProtocolFee = mulUp(amount, protocolFee, one(PercentageScale))

        let poolFee = amount - invariantProtocolFee

        if (poolFee == 0 && invariantProtocolFee == 0 || pool.liquidity.v == 0) {
            return pool
        }

        let feeGrowth = clamm.feeGrowthFromFee(pool.liquidity, poolFee)

        if (inX) {
            pool.feeGrowthGlobalX = wrappingAdd(pool.feeGrowthGlobalX, feeGrowth)
            pool.feeProtocolTokenX = pool.feeProtocolTokenX + invariantProtocolFee
        } else {
            pool.feeGrowthGlobalY = wrappingAdd(pool.feeGrowthGlobalY, feeGrowth)
            pool.feeProtocolTokenY = pool.feeProtocolTokenY + invariantProtocolFee
        }

        return pool
    }
    
    pub fn updatePoolLiquidity(mut pool: Pool, liquidityDelta: Liquidity, liquiditySign: Bool, upperTick: I256, lowerTick: I256) -> (U256, U256, Pool) {
        let (x, y, updateLiq) = clamm.calculateAmountDelta(pool.currentTickIndex, pool.sqrtPrice, liquidityDelta, liquiditySign, upperTick, lowerTick)
        if (!updateLiq) {
            return x, y, pool
        }

        if (liquiditySign) {
            pool.liquidity.v = pool.liquidity.v + liquidityDelta.v
        } else {
            pool.liquidity.v = pool.liquidity.v - liquidityDelta.v
        }

        return x, y, pool
    }

    @using(checkExternalCaller = false)
    pub fn poolUpdateTick(
        mut pool: Pool,
        nextSqrtPrice: SqrtPrice,
        swapLimit: SqrtPrice,
        mut remainingAmount: U256,
        byAmountIn: Bool,
        xToY: Bool,
        protocolFee: U256,
        hasLimitingTick: Bool,
        isLimitingTickInitialized: Bool,
        limitingTickIndex: I256
    ) -> (U256, U256, Bool, Pool) {
        let mut hasCrossed = false
        let mut totalAmount = 0

        if (!hasLimitingTick || swapLimit.v != nextSqrtPrice.v) {
            pool.currentTickIndex = clamm.getTickAtSqrtPrice(nextSqrtPrice, pool.poolKey.feeTier.tickSpacing)
            return totalAmount, remainingAmount, hasCrossed, pool
        }

        let isEnoughAmountToCross = clamm.isEnoughAmountToChangePrice(remainingAmount, nextSqrtPrice, pool.liquidity, pool.poolKey.feeTier.fee, byAmountIn, xToY)
        
        if (hasLimitingTick && isLimitingTickInitialized) {
            if (!xToY || isEnoughAmountToCross) {
                let tickKey = poolKeyBytes(pool.poolKey) ++ toByteVec!(limitingTickIndex)
                let tick = ticks[tickKey]
                let (add, liquidityDelta) = cross(pool.poolKey, tick, pool.feeGrowthGlobalX, pool.feeGrowthGlobalY, pool.currentTickIndex)
                pool = crossLiquidityUpdate(pool, add, liquidityDelta)
                hasCrossed = true
            } else if (remainingAmount != 0) {
                if (byAmountIn) {
                    pool = addFee(pool, remainingAmount, xToY, protocolFee)
                    totalAmount = remainingAmount
                }
                remainingAmount = 0
            } else {
                // do nothing
            }
        } else {
            // do nothing
        }

        if(xToY && isEnoughAmountToCross) {
            pool.currentTickIndex = limitingTickIndex - toI256!(pool.poolKey.feeTier.tickSpacing)
        } else {
            pool.currentTickIndex = limitingTickIndex
        }

        return totalAmount, remainingAmount, hasCrossed, pool
    }

    pub fn crossLiquidityUpdate(mut pool: Pool, add: Bool, liquidityDelta: Liquidity) -> Pool {
        if (add) {
            pool.liquidity.v = pool.liquidity.v + liquidityDelta.v
        } else {
            pool.liquidity.v = pool.liquidity.v - liquidityDelta.v
        }
        return pool
    }

    fn rewritePool(pool: Pool) -> () {
        let key = poolKeyBytes(pool.poolKey)
        pools[key] = pool
    }
}