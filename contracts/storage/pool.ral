Contract Pool(
    mut poolLiquidity: U256,
    poolCurrentSqrtPrice: U256,
    poolCurrentTickIndex: I256,
    mut poolFeeGrowthGlobalX: U256,
    mut poolFeeGrowthGlobalY: U256,
    mut poolFeeProtocolTokenX: U256,
    mut poolFeeProtocolTokenY: U256,
    poolStartTimestamp: U256,
    mut poolLastTimestamp: U256,
    mut poolFeeReceiver: Address,
    clammContractId: ByteVec
) extends Decimal() {
    pub fn getPoolLiquidity() -> U256 {
        return poolLiquidity
    }

    pub fn getPoolCurrentSqrtPrice() -> U256 {
        return poolCurrentSqrtPrice
    }

    pub fn getPoolCurrentTickIndex() -> I256 {
        return poolCurrentTickIndex
    }

    pub fn getFeeGrowthGlobalX() -> U256 {
        return poolFeeGrowthGlobalX
    }

    pub fn getFeeGrowthGlobalY() -> U256 {
        return poolFeeGrowthGlobalY
    }

    pub fn getFeeProtocolTokenX() -> U256 {
        return poolFeeProtocolTokenX
    }

    pub fn getFeeProtocolTokenY() -> U256 {
        return poolFeeProtocolTokenY
    }

    pub fn getStartTimestamp() -> U256 {
        return poolStartTimestamp
    }

    pub fn getLastTimestamp() -> U256 {
        return poolLastTimestamp
    }
    
    pub fn getFeeReceiver() -> Address {
        return poolFeeReceiver
    }

    pub fn get() -> (U256, U256, I256, U256, U256, U256, U256, U256, U256, Address) {
        return poolLiquidity, poolCurrentSqrtPrice, poolCurrentTickIndex, poolFeeGrowthGlobalX, poolFeeGrowthGlobalY, poolFeeProtocolTokenX, poolFeeProtocolTokenY, poolStartTimestamp, poolLastTimestamp, poolFeeReceiver
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn setFeeReceiver(recipient: Address) -> () {
        poolFeeReceiver = recipient
    }
    
    @using(updateFields = true, checkExternalCaller = false)
    pub fn setLastTimestamp(timestamp: U256) -> () {
        poolLastTimestamp = timestamp
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn addFee(amount: U256, inX: Bool, protocolFee: U256) -> () {
        let invariantProtocolFee = mulUp(amount, protocolFee, getPercentageScale())

        let poolFee = amount - invariantProtocolFee

        if (poolFee == 0 && invariantProtocolFee == 0 || getPoolLiquidity() == 0) {
            return
        }

        let feeGrowth = feeGrowthFromFee(getPoolLiquidity(), poolFee)

        if (inX) {
            poolFeeGrowthGlobalX = wrappingAdd(poolFeeGrowthGlobalX, feeGrowth)
            poolFeeProtocolTokenX = poolFeeProtocolTokenX + invariantProtocolFee
        } else {
            poolFeeGrowthGlobalY = wrappingAdd(poolFeeGrowthGlobalY, feeGrowth)
            poolFeeProtocolTokenY = poolFeeProtocolTokenY + invariantProtocolFee
        }
    }
    
    @using(updateFields = true, checkExternalCaller = false)
    pub fn updateLiquidity(liquidityDelta: U256, liquiditySign: Bool, upperTick: I256, lowerTick: I256) -> (U256, U256) {
        let (x, y, updateLiq) = CLAMM(clammContractId).calculateAmountDelta(getPoolCurrentTickIndex(), getPoolCurrentSqrtPrice(), liquidityDelta, liquiditySign, upperTick, lowerTick)
        if (!updateLiq) {
            return x, y
        }

        if (liquiditySign) {
            poolLiquidity = poolLiquidity + liquidityDelta
        } else {
            poolLiquidity = poolLiquidity - liquidityDelta
        }
        return x, y
    }

    // TODO
    // pub fn crossTick(
    //     nextSqrtPrice: U256,
    //     amountIn: U256,
    //     amountOut: U256,
    //     feeAmount: U256,
    //     swapLimit: U256,
    //     tick: U256,
    //     remainingAmount: U256,
    //     byAmountIn: Bool,
    //     xToY: Bool,
    //     currentTimestamp: U256,
    //     protocolFee: U256,
    //     feeTier: FeeTier
    //     ) -> (U256,Bool) {
    //     let mut hasCrossed = false
    //     let mut totalAmount = 0
    //     let fee = feeTier.getFee()

    //     if nextSqrtPrice == swapLimit {
    //         let isEnoughToCross = isEnoughToChangePrice(remainingAmount, nextSqrtPrice, getPoolLiquidity(), fee, byAmountIn, xToY)
    //         if( !xToY || isEnoughToCross) {     
    //         }
    //     }
    // }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn withdrawProtocolFee() -> (U256, U256) {
        let x = poolFeeProtocolTokenX
        let y = poolFeeProtocolTokenY
        poolFeeProtocolTokenX = 0
        poolFeeProtocolTokenY = 0
        return x, y
    }
}