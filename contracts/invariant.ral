Contract Invariant(
    mut init: Bool,
    admin: Address,
    mut protocolFee: U256,
    mut feeTiersContractId: ByteVec,
    feeTiersTemplateContractId: ByteVec,
    feeTierTemplateContractId: ByteVec,
    mut poolKeysContractId: ByteVec,
    poolKeysTemplateContractId: ByteVec,
    poolKeyTemplateContractId: ByteVec,
    mut poolsContractId: ByteVec,
    poolsTemplateContractId: ByteVec,
    poolTemplateContractId: ByteVec,
    mut ticksContractId: ByteVec,
    ticksTemplateContractId: ByteVec,
    tickTemplateContractId: ByteVec,
    mut positionsContractId: ByteVec,
    positionsTemplateContractId: ByteVec,
    positionTemplateContractId: ByteVec,
    positionsCounterTemplateContractId: ByteVec,
    mut tickmapContractId: ByteVec,
    tickmapTemplateContractId: ByteVec,
    chunkTemplateContractId: ByteVec,
    clammContractId: ByteVec
) extends Utils(), Decimal() {
    enum InvariantError {
        NotAdmin = 0
        AlreadyInitialized = 1
        NotInitialized = 2
        InvalidTickSpacing = 3
        InvalidFee = 4
        FeeTierNotFound = 5
        TokensAreSame = 6
        PoolKeyAlreadyExist = 7
        TickAndSqrtPriceMismatch = 8
        NotFeeReceiver = 9
        ZeroLiquidity = 10
        PriceLimitReached = 11
        ZeroAmount = 12
        WrongLimit = 13
        NoGainSwap = 14
    }

    @using(preapprovedAssets = true, updateFields = true, checkExternalCaller = false)
    pub fn init() -> () {
        assert!(callerAddress!() == admin, InvariantError.NotAdmin)
        assert!(!init, InvariantError.AlreadyInitialized)

        let (feeTiersEncodedImmFields, feeTiersEncodedMutFields) = FeeTiers.encodeFields!(selfAddress!(), feeTierTemplateContractId, 0)
        feeTiersContractId = copyCreateContract!{callerAddress!() -> ALPH: 1 alph}(feeTiersTemplateContractId, feeTiersEncodedImmFields, feeTiersEncodedMutFields)
        
        let (poolKeysEncodedImmFields, poolKeysEncodedMutFields) = PoolKeys.encodeFields!(selfAddress!(), poolKeyTemplateContractId, 0)
        poolKeysContractId = copyCreateContract!{callerAddress!() -> ALPH: 1 alph}(poolKeysTemplateContractId, poolKeysEncodedImmFields, poolKeysEncodedMutFields)
        
        let (poolsEncodedImmFields, poolsEncodedMutFields) = Pools.encodeFields!(poolTemplateContractId, clammContractId)
        poolsContractId = copyCreateContract!{callerAddress!() -> ALPH: 1 alph}(poolsTemplateContractId, poolsEncodedImmFields, poolsEncodedMutFields)

        let (ticksEncodedImmFields, ticksEncodedMutFields) = Ticks.encodeFields!(tickTemplateContractId)
        ticksContractId = copyCreateContract!{callerAddress!() -> ALPH: 1 alph}(ticksTemplateContractId, ticksEncodedImmFields, ticksEncodedMutFields)

        let (positionsEncodedImmFields, positionsEncodedMutFields) = Positions.encodeFields!(positionTemplateContractId, positionsCounterTemplateContractId)
        positionsContractId = copyCreateContract!{callerAddress!() -> ALPH: 1 alph}(positionsTemplateContractId, positionsEncodedImmFields, positionsEncodedMutFields)

        let (tickmapEncodedImmFields, tickmapEncodedMutFields) = Tickmap.encodeFields!(selfAddress!(), chunkTemplateContractId, clammContractId)
        tickmapContractId = copyCreateContract!{callerAddress!() -> ALPH: 1 alph}(tickmapTemplateContractId, tickmapEncodedImmFields, tickmapEncodedMutFields)
        
        init = true
    }
    
    pub fn getProtocolFee() -> U256 {
        return protocolFee
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn changeProtocolFee(newProtocolFee: U256) -> () {
        assert!(callerAddress!() == admin, InvariantError.NotAdmin)
        protocolFee = newProtocolFee
    }

    @using(checkExternalCaller = false)
    pub fn withdrawProtocolFee(token0: Address, token1: Address, fee: U256, tickSpacing: U256) -> () {
        let caller = callerAddress!()
        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)
        let pool = Pool(poolKey)

        assert!(pool.getFeeReceiver() == caller, InvariantError.NotFeeReceiver)

        let (feeProtocolTokenX, feeProtocolTokenY) = pool.withdrawProtocolFee()

        transferTokenFromSelf!(caller, toByteVec!(token0), feeProtocolTokenX)
        transferTokenFromSelf!(caller, toByteVec!(token1), feeProtocolTokenY)
    }

    @using(checkExternalCaller = false)
    pub fn changeFeeReceiver(token0: Address, token1: Address, fee: U256, tickSpacing: U256, newFeeReceiver: Address) -> () {
        let caller = callerAddress!()
        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)
        let pool = Pool(poolKey)

        assert!(admin == caller, InvariantError.NotFeeReceiver)

        pool.setFeeReceiver(newFeeReceiver)
    }

    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn createPool(token0: Address, token1: Address, fee: U256, tickSpacing: U256, initSqrtPrice: U256, initTick: I256) -> () {
        assert!(init, InvariantError.NotInitialized)

        let caller = callerAddress!()
        let contractAddress = selfAddress!()
        let timestamp = blockTimeStamp!()

        assert!(FeeTiers(feeTiersContractId).contains(fee, tickSpacing), InvariantError.FeeTierNotFound)

        CLAMM(clammContractId).checkTick(initTick, tickSpacing)

        assert!(token0 != token1, InvariantError.TokensAreSame)

        let poolKeyExist = PoolKeys(poolKeysContractId).contains(token0, token1, fee, tickSpacing)

        if (!poolKeyExist) {
            let swappedPoolKeyExist = PoolKeys(poolKeysContractId).contains(token0, token1, fee, tickSpacing)

            assert!(!swappedPoolKeyExist, InvariantError.PoolKeyAlreadyExist)
        }

        assert!(CLAMM(clammContractId).checkTickToSqrtPriceRelationship(initTick, tickSpacing, initSqrtPrice), InvariantError.TickAndSqrtPriceMismatch)

        PoolKeys(poolKeysContractId).add{caller -> ALPH: 1 alph}(caller, token0, token1, fee, tickSpacing)
        Pools(poolsContractId).add{caller -> ALPH: 1 alph}(caller, token0, token1, fee, tickSpacing, initSqrtPrice, initTick, timestamp, contractAddress)
    }

    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn addFeeTier(fee: U256, tickSpacing: U256) -> () {
        assert!(init, InvariantError.NotInitialized)

        let caller = callerAddress!()

        assert!(tickSpacing > 0 || tickSpacing <= 100, InvariantError.InvalidTickSpacing)
        assert!(fee <= 1000000000000, InvariantError.InvalidFee)
        assert!(caller == admin, InvariantError.NotAdmin)

        FeeTiers(feeTiersContractId).add{caller -> ALPH: 1 alph}(caller, fee, tickSpacing)
    }

    @using(checkExternalCaller = false)
    pub fn removeFeeTier(fee: U256, tickSpacing: U256) -> () {
        assert!(init, InvariantError.NotInitialized)
        assert!(callerAddress!() == admin, InvariantError.NotAdmin)

        FeeTiers(feeTiersContractId).remove(fee, tickSpacing)
    }

    pub fn feeTierExist(fee: U256, tickSpacing: U256) -> Bool {
        return FeeTiers(feeTiersContractId).contains(fee, tickSpacing)
    }

    pub fn getFeeTiers() -> ByteVec {
        return FeeTiers(feeTiersContractId).getAll()
    }

    pub fn getPools() -> ByteVec {
        return PoolKeys(poolKeysContractId).getAll()
    }

    pub fn getTick(token0: Address, token1: Address, fee: U256, tickSpacing: U256, index: I256) -> (Bool, Bool, U256, U256, U256, U256, U256, U256) {
        return Ticks(ticksContractId).get(generatePoolKey(token0, token1, fee, tickSpacing), index)
    }

    pub fn getPool(token0: Address, token1: Address, fee: U256, tickSpacing: U256) -> (Bool, U256, U256, I256, U256, U256, U256, U256, U256, U256, Address) {
        return Pools(poolsContractId).get(generatePoolKey(token0, token1, fee, tickSpacing))
    }

    pub fn getPosition(owner: Address, index: U256) -> (Bool, U256, I256, I256, U256, U256, U256, U256, U256) {
        return Positions(positionsContractId).get(owner, index)
    }

    pub fn isTickInitialized(token0: Address, token1: Address, fee: U256, tickSpacing: U256, index: I256) -> Bool {
        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)

        return Tickmap(tickmapContractId).get(index, tickSpacing, poolKey)
    }

    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn createTick(
        caller: Address,
        poolKey: ByteVec,
        tickSpacing: U256,
        index: I256,
        currentTickIndex: I256,
        feeGrowthGlobalX: U256,
        feeGrowthGlobalY: U256,
        startTimestamp: U256
    ) -> () {
        CLAMM(clammContractId).checkTick(index, tickSpacing)

        let mut feeGrowthOutsideX = 0
        let mut feeGrowthOutsideY = 0
        let mut secondsOutside = 0

        if (index <= currentTickIndex) {
            feeGrowthOutsideX = feeGrowthGlobalX
            feeGrowthOutsideY = feeGrowthGlobalY
            secondsOutside = blockTimeStamp!() - startTimestamp
        }

        Ticks(ticksContractId).add{caller -> ALPH: 1 alph}(
            caller,
            poolKey,
            index,
            true,
            0,
            0,
            CLAMM(clammContractId).calculateSqrtPrice(index),
            feeGrowthOutsideX,
            feeGrowthOutsideY, 
            0
        )

        Tickmap(tickmapContractId).flip{caller -> ALPH: 1 alph}(caller, index, tickSpacing, poolKey)
    }

    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn initPosition(
        token0: Address,
        token1: Address,
        fee: U256,
        tickSpacing: U256,
        lowerTick: I256,
        upperTick: I256
    ) -> () {
        let pools = Pools(poolsContractId) 
        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)

        let currentTickindex = pools.getCurrentTickIndex(poolKey)
        let (feeGrowthGlobalX, feeGrowthGlobalY) = pools.getFeeGrowthGlobal(poolKey)
        let startTimestamp = pools.getStartTimestamp(poolKey)

        let ticks = Ticks(ticksContractId)
        let caller = callerAddress!()
 
        if(!ticks.exist(poolKey, lowerTick)) {
            createTick{caller -> ALPH: 2 alph}(caller, poolKey, tickSpacing, lowerTick, currentTickindex, feeGrowthGlobalX, feeGrowthGlobalY, startTimestamp)
        }

        if(!ticks.exist(poolKey, upperTick)) {
            createTick{caller -> ALPH: 2 alph}(caller, poolKey, tickSpacing, upperTick, currentTickindex, feeGrowthGlobalX, feeGrowthGlobalY, startTimestamp)
        }

        Positions(positionsContractId).add{caller -> ALPH: 2 alph}(caller, 0, lowerTick, upperTick, 0, 0, blockTimeStamp!(), 0, 0)
    }

    @using(checkExternalCaller = false)
    pub fn createPosition(
        index: U256,
        token0: Address,
        token1: Address,
        fee: U256,
        tickSpacing: U256,
        lowerTick: I256,
        upperTick: I256,
        liquidityDelta: U256,
        slippageLimitLower: U256,
        slippageLimitUpper: U256
    ) -> () {
        let pools = Pools(poolsContractId)
        let caller = callerAddress!()
        let currentTimestamp = blockTimeStamp!()

        assert!(liquidityDelta != 0, InvariantError.ZeroLiquidity)

        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)
        let poolCurrentSqrtPrice = pools.getCurrentSqrtPrice(poolKey)

        assert!(poolCurrentSqrtPrice >= slippageLimitLower && poolCurrentSqrtPrice <= slippageLimitUpper, InvariantError.PriceLimitReached)

        modify(caller, index, poolKey, upperTick, lowerTick, liquidityDelta, true, currentTimestamp, tickSpacing)
    }

    @using(updateFields = false, checkExternalCaller = false)
    pub fn modify(
        caller: Address,
        index: U256,
        poolKey: ByteVec,
        upperTick: I256,
        lowerTick: I256,
        liquidityDelta: U256,
        add: Bool,
        currentTimestamp: U256,
        tickSpacing: U256
    ) -> (U256, U256) {
        let pools = Pools(poolsContractId)

        pools.setLastTimestamp(poolKey, currentTimestamp)

        let maxLiquidityPerTick = CLAMM(clammContractId).calculateMaxLiquidityPerTick(tickSpacing)

        let ticks = Ticks(ticksContractId)

        ticks.updateTick(poolKey, lowerTick, liquidityDelta, maxLiquidityPerTick, false, add)
        ticks.updateTick(poolKey, upperTick, liquidityDelta, maxLiquidityPerTick, true, add)

        let (lowerTickFeeGrowthOutsideX, lowerTickFeeGrowthOutsideY) = ticks.getFeeGrowthOutside(poolKey, lowerTick)
        let (upperTickFeeGrowthOutsideX, upperTickFeeGrowthOutsideY) = ticks.getFeeGrowthOutside(poolKey, upperTick)
        let poolCurrentTickIndex = pools.getCurrentTickIndex(poolKey)
        let (poolFeeGrowthGlobalX, poolFeeGrowthGlobalY) = pools.getFeeGrowthGlobal(poolKey)

        let (feeGrowthInsideX, feeGrowthInsideY) = CLAMM(clammContractId).calculateFeeGrowthInside(
            lowerTick,
            lowerTickFeeGrowthOutsideX,
            lowerTickFeeGrowthOutsideY,
            upperTick,
            upperTickFeeGrowthOutsideX,
            upperTickFeeGrowthOutsideY,
            poolCurrentTickIndex,
            poolFeeGrowthGlobalX,
            poolFeeGrowthGlobalY
        )

        Positions(positionsContractId).update(caller, index, add, liquidityDelta, feeGrowthInsideX, feeGrowthInsideY)

        return pools.updateLiquidity(poolKey, liquidityDelta, add, upperTick, lowerTick)
    }


    @using(checkExternalCaller = false)
    pub fn calculateSwap(
        poolKey: ByteVec,
        xToY: Bool,
        amount: U256,
        byAmountIn: Bool,
        sqrtPriceLimit: U256,
        fee: U256,
        tickSpacing: U256
    ) -> (U256, U256, U256, U256, U256) {
        let currentTimestamp = blockTimeStamp!()

        assert!(amount != 0, InvariantError.ZeroAmount)

        // let mut ticks = 
        
        let currentSqrtPrice = Pools(poolsContractId).getCurrentSqrtPrice(poolKey)
        assert!(!xToY && currentSqrtPrice > sqrtPriceLimit && sqrtPriceLimit <= getMaxSqrtPrice() 
        || xToY && currentSqrtPrice < sqrtPriceLimit && sqrtPriceLimit >= getMinSqrtPrice(), InvariantError.WrongLimit)

        let mut remainingAmount = amount

        let mut totalAmountIn = 0
        let mut totalAmountOut = 0

        let eventStartSqrtPrice = currentSqrtPrice
        let mut eventFeeAmount = 0

        while (remainingAmount != 0) {
            let currentTickIndex = Pools(poolsContractId).getCurrentTickIndex(poolKey)
            let currentLiquidity = Pools(poolsContractId).getCurrentLiquidity(poolKey)
            let (swapLimit, hasLimitingTick, limitingTickIndex, isInitialized) = Tickmap(tickmapContractId).getCloserLimit(sqrtPriceLimit, xToY, currentTickIndex, tickSpacing, poolKey)

            let (nextSqrtPrice, amountIn, amountOut, feeAmount) = CLAMM(clammContractId).computeSwapStep(
                currentSqrtPrice,
                swapLimit,
                currentLiquidity,
                remainingAmount,
                byAmountIn,
                fee
            )

            if (byAmountIn) {
                remainingAmount = remainingAmount - (amountIn + feeAmount)
            } else {
                remainingAmount = remainingAmount - amountOut
            }

            Pools(poolsContractId).wrappedAddFee(poolKey, feeAmount, xToY, fee)

            eventFeeAmount = eventFeeAmount + feeAmount

            Pools(poolsContractId).setSqrtPrice(poolKey, nextSqrtPrice)

            totalAmountIn = totalAmountIn + amountIn + feeAmount
            totalAmountOut = totalAmountOut + amountOut

            assert!(nextSqrtPrice != sqrtPriceLimit || remainingAmount == 0, InvariantError.PriceLimitReached)

            if (hasLimitingTick) {
                if (isInitialized) {
                    let (amountToAdd, updatedRemainingAmount, hasCrossed) = Pools(poolsContractId).wrappedCrossTick(
                        poolKey,
                        nextSqrtPrice,
                        // amountIn,
                        // amountOut,
                        // feeAmount,
                        swapLimit,
                        limitingTickIndex,
                        remainingAmount,
                        byAmountIn,
                        xToY,
                        protocolFee,
                        fee,
                        tickSpacing
                    )
                    remainingAmount = updatedRemainingAmount
                    totalAmountIn = totalAmountIn + amountToAdd

                    if (hasCrossed) {
                        let (feeGrowthGlobalX, feeGrowthGlobalY) = Pools(poolsContractId).getFeeGrowthGlobal(poolKey)
                        let (add, liquidityDelta) = Ticks(ticksContractId).wrappedCross(poolKey, limitingTickIndex, feeGrowthGlobalX, feeGrowthGlobalY, currentTickIndex)
                        Pools(poolsContractId).wrappedCrossLiquidityUpdate(poolKey, add, liquidityDelta)
                    }
                }
            } else {
                let newTickIndex = CLAMM(clammContractId).getTickAtSqrtPrice(nextSqrtPrice, tickSpacing)
                Pools(poolsContractId).setTickIndex(poolKey, newTickIndex)
                Pools(poolsContractId).setLastTimestamp(poolKey, currentTimestamp)
            }
        }
        
        assert!(totalAmountOut != 0, InvariantError.NoGainSwap)

        return totalAmountIn, totalAmountOut, eventStartSqrtPrice, Pools(poolsContractId).getCurrentSqrtPrice(poolKey), eventFeeAmount
    }


    // @using(updateFields = false, checkExternalCaller = false)
    // pub fn quote(
    //     token0: Address,
    //     token1: Address,
    //     fee: U256,
    //     tickSpacing: U256,
    //     xToY: Bool,
    //     amount: U256,
    //     byAmountIn: Bool,
    //     sqrtPriceLimit: U256
    // ) -> () {
    //     let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)
    //     let calculateSwapResult = calculateSwap(poolKey, xToY, amount, byAmountIn, sqrtPriceLimit, fee, tickSpacing)
    //     return
    // }

    // @using(updateFields = false, checkExternalCaller = false)
    // pub fn swap() -> () {
    //     return
    // }
    

    // @using(updateFields = true, checkExternalCaller = false)
    // pub fn claimFee(
    //     poolsContractId: ByteVec,
    //     ticksContractId: ByteVec,
    //     poolKey: ByteVec,
    //     upperTick: I256,
    //     lowerTick: I256,
    //     currentTimestamp: U256,
    //     tickSpacing: U256
    // ) -> (U256, U256) {
    //     modify(poolsContractId, ticksContractId, poolKey, upperTick, lowerTick, 0, true, currentTimestamp, tickSpacing)

    //     let tokensOwedX = posTokensOwedX
    //     let tokensOwedY = posTokensOwedY

    //     posTokensOwedX = 0
    //     posTokensOwedY = 0

    //     return tokensOwedX, tokensOwedY
    // }
}
