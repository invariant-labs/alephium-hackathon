Contract FeeTier(admin: Address, fee: U256, tickSpacing: U256, mut isActive: Bool) {
    enum FeeTierError {
        NotAdmin = 0
    }
    
    pub fn getFee() -> U256 {
      return fee
    }

    pub fn getTickSpacing() -> U256 {
      return tickSpacing
    }

    pub fn isActive() -> Bool {
      return isActive
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn setActive(active: Bool) -> () {
        assert!(callerAddress!() == admin, FeeTierError.NotAdmin)
        isActive = active
    }
}

Contract Invariant(
    admin: Address,
    protocolFee: U256,
    feeTierTemplateContractId: ByteVec,
    mut feeTierCount: U256
    // poolKeyTemplateContractId: ByteVec,
    // poolKeyCount: U256
) extends CLAMM() {
    enum InvariantError {
        InvalidTickSpacing = 0
        InvalidFee = 1
        NotAdmin = 2
        FeeTierAlreadyExist = 3
        FeeTierNotFound = 4
    }

    pub fn getProtocolFee() -> U256 {
        return protocolFee
    }

    // @using(preapprovedAssets = true, updateFields = true, checkExternalCaller = false)
    // pub fn createPool(token0: Address, token1: Address, feeTier: FeeTier, initSqrtPrice: U256, initTick: I256) -> () {
    //     let caller = callerAddress!()
    //     let timestamp = blockTimeStamp!()


    //     // feeTierExist(feeTier)
    //     // poolKeyExist(token0, token1, feeTier)
    //     // Create Pool Key
    //     let (encodedImmFields, encodedMutFields) = PoolKey.encodeFields!(selfAddress!(), token0, token1, feeTier)
    //     poolKeyCount = poolKeyCount + 1
    //     copyCreateSubContract!{caller -> ALPH: 1 alph}(
    //         toByteVec!(poolKeyCount),
    //         poolKeyTemplateContractId,
    //         encodedImmFields,
    //         encodedMutFields
    //     )
    // }

    @using(preapprovedAssets = true, updateFields = true, checkExternalCaller = false)
    pub fn addFeeTier(fee: U256, tickSpacing: U256) -> () {
        let caller = callerAddress!()

        assert!(tickSpacing > 0 || tickSpacing <= 100, InvariantError.InvalidTickSpacing)
        assert!(fee <= 1000000000000, InvariantError.InvalidFee)
        assert!(caller == admin, InvariantError.NotAdmin)

        for (let mut i = 1; i <= feeTierCount; i = i + 1) {
            let contract = FeeTier(subContractId!(toByteVec!(i)))
            
            let existingFee = contract.getFee()
            let existingTickSpacing = contract.getTickSpacing()
            let existingIsActive = contract.isActive()

            if (!existingIsActive) {
                contract.setActive(true)
                return
            }

            assert!((fee != existingFee || tickSpacing != existingTickSpacing), InvariantError.FeeTierAlreadyExist)
        }

        feeTierCount = feeTierCount + 1
        let (encodedImmFields, encodedMutFields) = FeeTier.encodeFields!(selfAddress!(), fee, tickSpacing, true)
        copyCreateSubContract!{caller -> ALPH: 1 alph}(
            toByteVec!(feeTierCount),
            feeTierTemplateContractId,
            encodedImmFields,
            encodedMutFields
        )
    }

    @using(checkExternalCaller = false)
    pub fn removeFeeTier(fee: U256, tickSpacing: U256) -> () {
        for (let mut i = 1; i <= feeTierCount; i = i + 1) {
            let contract = FeeTier(subContractId!(toByteVec!(i)))

            let existingFee = contract.getFee()
            let existingTickSpacing = contract.getTickSpacing()
            let existingIsActive = contract.isActive()

            if (fee == existingFee && tickSpacing == existingTickSpacing && existingIsActive) {
                contract.setActive(false)
                return
            }
        }

        assert!(false, InvariantError.FeeTierNotFound)
    }

    pub fn getFeeTierCount() -> U256 {
        let mut count = 0

        for (let mut index = 1; index <= feeTierCount; index = index + 1) {
            let path = toByteVec!(index)
            let contractId = subContractId!(path)
            let contract = FeeTier(contractId)
            let isActive = contract.isActive()

            if (isActive) {
                count = count + 1
            }
        }

        return count
    }
}