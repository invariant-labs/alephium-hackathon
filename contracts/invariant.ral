Contract Invariant(
    mut init: Bool,
    admin: Address,
    mut protocolFee: U256,
    mut feeTiersContractId: ByteVec,
    feeTiersTemplateContractId: ByteVec,
    feeTierTemplateContractId: ByteVec,
    mut poolKeysContractId: ByteVec,
    poolKeysTemplateContractId: ByteVec,
    poolKeyTemplateContractId: ByteVec,
    mut poolsContractId: ByteVec,
    poolsTemplateContractId: ByteVec,
    poolTemplateContractId: ByteVec,
    mut ticksContractId: ByteVec,
    ticksTemplateContractId: ByteVec,
    tickTemplateContractId: ByteVec,
    mut positionsContractId: ByteVec,
    positionsTemplateContractId: ByteVec,
    positionTempalteContractId: ByteVec,
    mut positionsCounterContractId: ByteVec,
    positionsCounterTemplateContractId: ByteVec,
    mut tickmapContractId: ByteVec,
    tickmapTemplateContractId: ByteVec,
    chunkTemplateContractId: ByteVec,
    clammContractId: ByteVec
) extends Utils() {
    event CreatePositionEvent(address: Address, pool: ByteVec, liquidity: U256, lowerTickIndex: I256, upperTickIndex: I256, currentSqrtPrice: U256)
    event RemovePositionEvent(address: Address, pool: ByteVec, liquidity: U256, lowerTickIndex: I256, upperTickIndex: I256, currentSqrtPrice: U256)

    enum InvariantError {
        NotAdmin = 0
        AlreadyInitialized = 1
        NotInitialized = 2
        InvalidTickSpacing = 3
        InvalidFee = 4
        FeeTierNotFound = 5
        TokensAreSame = 6
        PoolKeyAlreadyExist = 7
        TickAndSqrtPriceMismatch = 8
        ZeroLiquidity = 9
        PriceLimitReached = 10
        NotFeeReceiver = 11
    }
    

    @using(preapprovedAssets = true, updateFields = true, checkExternalCaller = false)
    pub fn init() -> () {
        assert!(callerAddress!() == admin, InvariantError.NotAdmin)
        assert!(!init, InvariantError.AlreadyInitialized)

        let (feeTiersEncodedImmFields, feeTiersEncodedMutFields) = FeeTiers.encodeFields!(selfAddress!(), feeTierTemplateContractId, 0)
        feeTiersContractId = copyCreateContract!{callerAddress!() -> ALPH: 1 alph}(feeTiersTemplateContractId, feeTiersEncodedImmFields, feeTiersEncodedMutFields)
        
        let (poolKeysEncodedImmFields, poolKeysEncodedMutFields) = PoolKeys.encodeFields!(selfAddress!(), poolKeyTemplateContractId, 0)
        poolKeysContractId = copyCreateContract!{callerAddress!() -> ALPH: 1 alph}(poolKeysTemplateContractId, poolKeysEncodedImmFields, poolKeysEncodedMutFields)
        
        let (poolsEncodedImmFields, poolsEncodedMutFields) = Pools.encodeFields!(selfAddress!(), poolTemplateContractId, clammContractId)
        poolsContractId = copyCreateContract!{callerAddress!() -> ALPH: 1 alph}(poolsTemplateContractId, poolsEncodedImmFields, poolsEncodedMutFields)

        let (ticksEncodedImmFields, ticksEncodedMutFields) = Ticks.encodeFields!(selfAddress!(), tickTemplateContractId, clammContractId)
        ticksContractId = copyCreateContract!{callerAddress!() -> ALPH: 1 alph}(ticksTemplateContractId, ticksEncodedImmFields, ticksEncodedMutFields)

        let (positionsCounterEncodedImmFields, positionsCounterEncodedMutFields) = PositionsCounter.encodeFields!(selfAddress!(), 0)   
        positionsCounterContractId = copyCreateContract!{callerAddress!() -> ALPH: 1 alph}(positionsCounterTemplateContractId, positionsCounterEncodedImmFields, positionsCounterEncodedMutFields)

        let (positionsEncodedImmFields, positionsEncodedMutFields) = Positions.encodeFields!(selfAddress!(), positionTempalteContractId, clammContractId, positionsCounterContractId)
        positionsContractId = copyCreateContract!{callerAddress!() -> ALPH: 1 alph}(positionsTemplateContractId, positionsEncodedImmFields, positionsEncodedMutFields)

        let (tickmapEncodedImmFields, tickmapEncodedMutFields) = Tickmap.encodeFields!(selfAddress!(), chunkTemplateContractId, clammContractId)
        tickmapContractId = copyCreateContract!{callerAddress!() -> ALPH: 1 alph}(tickmapTemplateContractId, tickmapEncodedImmFields, tickmapEncodedMutFields)
        
        init = true
    }
    
    pub fn getProtocolFee() -> U256 {
        return protocolFee
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn changeProtocolFee(newProtocolFee: U256) -> () {
        assert!(callerAddress!() == admin, InvariantError.NotAdmin)
        protocolFee = newProtocolFee
    }

    @using(checkExternalCaller = false)
    pub fn withdrawProtocolFee(token0: Address, token1: Address, fee: U256, tickSpacing: U256) -> () {
        let caller = callerAddress!()
        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)
        let pool = Pool(poolKey)

        assert!(pool.getFeeReceiver() == caller, InvariantError.NotFeeReceiver)

        let (feeProtocolTokenX, feeProtocolTokenY) = pool.withdrawProtocolFee()

        transferTokenFromSelf!(caller, toByteVec!(token0), feeProtocolTokenX)
        transferTokenFromSelf!(caller, toByteVec!(token1), feeProtocolTokenY)
    }

    @using(checkExternalCaller = false)
    pub fn changeFeeReceiver(token0: Address, token1: Address, fee: U256, tickSpacing: U256, newFeeReceiver: Address) -> () {
        let caller = callerAddress!()
        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)
        let pool = Pool(poolKey)

        assert!(admin == caller, InvariantError.NotFeeReceiver)

        pool.setFeeReceiver(newFeeReceiver)
    }

    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn createPool(token0: Address, token1: Address, fee: U256, tickSpacing: U256, initSqrtPrice: U256, initTick: I256) -> () {
        assert!(init, InvariantError.NotInitialized)

        let caller = callerAddress!()
        let contractAddress = selfAddress!()
        let timestamp = blockTimeStamp!()

        assert!(FeeTiers(feeTiersContractId).contains(fee, tickSpacing), InvariantError.FeeTierNotFound)

        CLAMM(clammContractId).checkTick(initTick, tickSpacing)

        assert!(token0 != token1, InvariantError.TokensAreSame)

        let poolKeyExist = PoolKeys(poolKeysContractId).contains(token0, token1, fee, tickSpacing)

        if (!poolKeyExist) {
            let swappedPoolKeyExist = PoolKeys(poolKeysContractId).contains(token0, token1, fee, tickSpacing)

            assert!(!swappedPoolKeyExist, InvariantError.PoolKeyAlreadyExist)
        }

        assert!(CLAMM(clammContractId).checkTickToSqrtPriceRelationship(initTick, tickSpacing, initSqrtPrice), InvariantError.TickAndSqrtPriceMismatch)

        PoolKeys(poolKeysContractId).add{caller -> ALPH: 1 alph}(caller, token0, token1, fee, tickSpacing)
        Pools(poolsContractId).add{caller -> ALPH: 1 alph}(caller, token0, token1, fee, tickSpacing, initSqrtPrice, initTick, timestamp, contractAddress)
    }

    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn addFeeTier(fee: U256, tickSpacing: U256) -> () {
        assert!(init, InvariantError.NotInitialized)

        let caller = callerAddress!()

        assert!(tickSpacing > 0 || tickSpacing <= 100, InvariantError.InvalidTickSpacing)
        assert!(fee <= 1000000000000, InvariantError.InvalidFee)
        assert!(caller == admin, InvariantError.NotAdmin)

        FeeTiers(feeTiersContractId).add{caller -> ALPH: 1 alph}(caller, fee, tickSpacing)
    }

    @using(checkExternalCaller = false)
    pub fn removeFeeTier(fee: U256, tickSpacing: U256) -> () {
        assert!(init, InvariantError.NotInitialized)
        assert!(callerAddress!() == admin, InvariantError.NotAdmin)

        FeeTiers(feeTiersContractId).remove(fee, tickSpacing)
    }

    pub fn feeTierExist(fee: U256, tickSpacing: U256) -> Bool {
        return FeeTiers(feeTiersContractId).contains(fee, tickSpacing)
    }

    // TODO: remove if possible after implementing get fee tiers
    pub fn getFeeTierCount() -> U256 {
        return FeeTiers(feeTiersContractId).count()
    }

    // TODO: Should not be pub
    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn createTick(caller: Address, poolKey: ByteVec, tickSpacing: U256, index: I256) -> ByteVec {
        let currentTimestamp = blockTimeStamp!()
        let ticks = Ticks(ticksContractId)
        let (poolIndex, poolFeeGrowthGlobalX, poolFeeGrowthGlobalY, lastTimestamp) = Pools(poolsContractId).getCreateTickParams(poolKey)
        let belowCurrentTick = index <= poolIndex

        CLAMM(clammContractId).checkTick(index, tickSpacing)

        let (doesTickExist, isTickInitialiazed) = ticks.exist(poolKey, index)         

        let mut feeGrowthOutsideX = 0
        let mut feeGrowthOutisdeY = 0
        let mut secondsOutside = 0
        if (belowCurrentTick) {
            feeGrowthOutsideX = poolFeeGrowthGlobalX
            feeGrowthOutisdeY = poolFeeGrowthGlobalY
            secondsOutside = currentTimestamp - lastTimestamp
        }

        if (!doesTickExist && !isTickInitialiazed) {
            ticks.add{caller -> ALPH: 1 alph}(caller, poolKey, index, true)
        }
        if (doesTickExist && !isTickInitialiazed) {
            ticks.reinitializeTick(poolKey, index, poolIndex, feeGrowthOutsideX, feeGrowthOutisdeY, lastTimestamp, currentTimestamp)
        }

        let tickContractId = subContractId!(poolKey ++ toByteVec!(index))
        
        // MISSING APPROVED ASSETS
        // Tickmap(tickmapContractId).flip{caller -> ALPH: 1 alph}(index, tickSpacing, poolKey)

        return tickContractId
    }


    // TODO: remove at the end
    pub fn tickExist(poolKey: ByteVec, index: I256) -> (Bool, Bool) {
        return Ticks(ticksContractId).exist(poolKey, index)
    }

    // TODO: implement
    pub fn getFeeTiers() -> () {}

    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn createPosition(
        token0: Address,
        token1: Address,
        fee: U256,
        tickSpacing: U256,
        lowerTickIndex: I256,
        upperTickIndex: I256,
        liquidityDelta: U256,
        slippageLimitLower: U256,
        slippageLimitUpper: U256
    ) -> ByteVec {
        let caller = callerAddress!()
        // Flow
        // - create Tick || getTick || Reinitialize Tick => Ticks collection
        // - createPosition => Positions collection
        // - modify position => Position contract
        //      - setLastTimestamp => Pool Contract => Pools Collection
        //      - updateTick => Tick Contract => Ticks Collection
        //      - pool update liquidity => Pool Contract => Pools Collection
        // transfter tokens
        // emit event
        // return 
        let timestamp = blockTimeStamp!()

        assert!(liquidityDelta != 0, InvariantError.ZeroLiquidity)
        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)
        let currentSqrtPrice = Pools(poolsContractId).getSelectedPoolSqrtPrice(poolKey)

        assert!(currentSqrtPrice >= slippageLimitLower && currentSqrtPrice <= slippageLimitUpper, InvariantError.PriceLimitReached)
        assert!(lowerTickIndex < upperTickIndex, InvariantError.PriceLimitReached)
        let positions = Positions(positionsContractId)
        // let ticks = Ticks(ticksContractId)
        // let pools = Pools(poolsContractId)

        let lowerTickId = createTick{caller -> ALPH: 1 alph}(caller, poolKey, tickSpacing, lowerTickIndex)
        let upperTickId = createTick{caller -> ALPH: 1 alph}(caller, poolKey, tickSpacing, upperTickIndex)

        let positionId = positions.add{caller -> ALPH: 2 alph}(caller, poolKey, liquidityDelta, lowerTickIndex, upperTickIndex, timestamp, 0, 0, 0, 0)
        if(positionId == toByteVec!(1)) {
            return toByteVec!(2)
        }
        // let (_, lowerTickFeeGrowthOutsideX, lowerTickFeeGrowthOutsideY) = ticks.getModifyParams(lowerTickId)
        // let (_, upperTickFeeGrowthOutsideX, upperTickFeeGrowthOutsideY) = ticks.getModifyParams(upperTickId)
        // let (poolIndex, poolFeeGrowthGlobalX, poolFeeGrowthGlobalY) = pools.getModifyParams(poolKey)
        Positions(positionsContractId).wrappedModify(
                    positionId
                    // lowerTickIndex,
                    // lowerTickFeeGrowthOutsideX,
                    // lowerTickFeeGrowthOutsideY,
                    // upperTickIndex,
                    // upperTickFeeGrowthOutsideX,
                    // upperTickFeeGrowthOutsideY,
                    // poolIndex,
                    // poolFeeGrowthGlobalX,
                    // poolFeeGrowthGlobalY,
                    // true,
                    // liquidityDelta
                )
        // let (_, _) = position.modify(poolKey, lowerTickId, upperTickId, liquidityDelta, true, timestamp, tickSpacing)

        // transferTokenToSelf!(caller, toByteVec!(token0), requiredX)
        // transferTokenToSelf!(caller, toByteVec!(token1), requiredY)

        // emit CreatePositionEvent(caller, poolKey, liquidityDelta, lowerTickIndex, upperTickIndex, currentPoolSqrtPrice)
        // return positionId

        if (lowerTickId == upperTickId) {
            return toByteVec!(0)
        }

        return toByteVec!(0)
    }

    // @using(preapprovedAssets = true, checkExternalCaller = false)
    // pub fn removePosition(
    //     token0: Address,
    //     token1: Address,
    //     fee: U256,
    //     tickSpacing: U256,
    //     index: U256
    // ) -> (U256, U256) {
    //     let caller = callerAddress!()
    //     let timestamp = blockTimeStamp!()
    //     let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)
    //     let pool = Pool(poolKey)
    //     let positionId = Positions(positionsContractId).getId(selfAddress!(), poolKey, index)
    //     let position = Position(positionId)
    //     let withdrawedLiquidity = position.getPosLiquidity()
    //     let lowerTickIndex = position.getPosLowerTickIndex()
    //     let upperTickIndex = position.getPosUpperTickIndex()
    //     let lowerTickId = poolKey ++ toByteVec!(lowerTickIndex)
    //     let upperTickId = poolKey ++ toByteVec!(upperTickIndex)
        
    //     let (amountX, amountY, deinitializeLowerTick, deinitializeUpperTick) = position.remove(poolKey, lowerTickId, upperTickId, timestamp, tickSpacing)
    //     if (deinitializeLowerTick) {
    //         Ticks(ticksContractId).deinitializeTick(poolKey, lowerTickIndex)
    //     }
    //     if (deinitializeUpperTick) {
    //         Ticks(ticksContractId).deinitializeTick(poolKey, upperTickIndex)
    //     }

    //     Positions(positionsContractId).remove(caller, poolKey, index)

    //     transferTokenFromSelf!(caller, toByteVec!(token0), amountX)
    //     transferTokenFromSelf!(caller, toByteVec!(token1), amountY)

    //     emit RemovePositionEvent(caller, poolKey, withdrawedLiquidity, lowerTickIndex, upperTickIndex, pool.getPoolCurrentSqrtPrice())

    //     return amountX, amountY
    // }

    // @using(preapprovedAssets = true, checkExternalCaller = false)
    // pub fn claimFee(
    //     token0: Address,
    //     token1: Address,
    //     fee: U256,
    //     tickSpacing: U256,
    //     index: U256
    // ) -> (U256, U256) {
    //     let caller = callerAddress!()
    //     let currentTimestamp = blockTimeStamp!()
    //     let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)

    //     let positionId = Positions(positionsContractId).getId(selfAddress!(), poolKey, index)
    //     let position = Position(positionId)
        
    //     let lowerTickIndex = position.getPosLowerTickIndex()
    //     let upperTickIndex = position.getPosUpperTickIndex()
    //     let lowerTickId = poolKey ++ toByteVec!(lowerTickIndex)
    //     let upperTickId = poolKey ++ toByteVec!(upperTickIndex)

    //     let (amountX, amountY) = position.claimFee(poolKey, lowerTickId, upperTickId, currentTimestamp, tickSpacing)

    //     transferTokenFromSelf!(caller, toByteVec!(token0), amountX)
    //     transferTokenFromSelf!(caller, toByteVec!(token1), amountY)

    //     return amountX, amountY
    // }

    // @using(preapprovedAssets = true, checkExternalCaller = false)
    // pub fn transferPosition(
    //     token0: Address,
    //     token1: Address,
    //     fee: U256,
    //     tickSpacing: U256,
    //     index: U256,
    //     receiver: Address
    // ) -> () {
    //     let caller = callerAddress!()
    //     let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)
    //     Positions(positionsContractId).transfer{caller -> ALPH: 1 alph}(selfAddress!(), receiver, poolKey, index)
    // }

    pub fn getPools() -> ByteVec {
        return PoolKeys(poolKeysContractId).getAll()
    }

    pub fn getPool(token0: Address, token1: Address, fee: U256, tickSpacing: U256) -> (Bool, ByteVec) {
        return Pools(poolsContractId).get(token0, token1, fee, tickSpacing)
    }

    pub fn getTick(token0: Address, token1: Address, fee: U256, tickSpacing: U256, index: I256) -> (Bool, ByteVec) {
        return Ticks(ticksContractId).get(generatePoolKey(token0, token1, fee, tickSpacing), index)
    }

    pub fn isTickInitialized(token0: Address, token1: Address, fee: U256, tickSpacing: U256, index: I256) -> Bool {
        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)

        return Tickmap(tickmapContractId).get(index, tickSpacing, poolKey)
    }

    pub fn getPosition(token0: Address, token1: Address, fee: U256, tickSpacing: U256, owner: Address, index: U256) -> (Bool, ByteVec) {
        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)

        return Positions(positionsContractId).get(owner, index, poolKey)
    }
}
