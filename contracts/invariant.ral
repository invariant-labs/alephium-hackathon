struct InvariantConfig { admin: Address, mut protocolFee: U256 }

struct SwapResult {
    nextSqrtPrice: U256,
    amountIn: U256,
    amountOut: U256,
    feeAmount: U256
}

struct CalculateSwapResult {
    amountIn: U256,
    amountOut: U256,
    startSqrtPrice: U256,
    targetSqrtPrice: U256,
    fee: U256
}

struct QuoteResult {
    amountIn: U256,
    amountOut: U256,
    targetSqrtPrice: U256
}

Contract Invariant(
    mut init: Bool,
    mut config: InvariantConfig,
    positionTemplateContractId: ByteVec,
    positionsCounterContractId: ByteVec,
    clamm: CLAMM,
    mut feeTierCount: U256,
    mut poolKeyCount: U256
) extends PoolKeyHelper(), Decimal(), FeeTiers(), PoolKeys(), Pools(clamm), Ticks(), Tickmap() {
    // Key: feeTierCount
    mapping[U256, FeeTier] feeTiers
    // Key: poolKeyCount
    mapping[U256, PoolKey] poolKeys
    // Key: poolKey
    mapping[ByteVec, Pool] pools
    // Key: poolKey ++ index
    mapping[ByteVec, Tick] ticks
    // Key: poolKey ++ chunk index
    mapping[ByteVec, U256] bitmap
    

    enum InvariantError {
        NotAdmin = 0
        AlreadyInitialized = 1
        NotInitialized = 2
        InvalidTickSpacing = 3
        InvalidFee = 4
        FeeTierNotFound = 5
        TokensAreSame = 6
        PoolKeyAlreadyExist = 7
        TickAndSqrtPriceMismatch = 8
        NotFeeReceiver = 9
        ZeroLiquidity = 10
        PriceLimitReached = 11
        InvalidProtocolFee = 12
        NotOwner = 13
        ZeroAmount = 14
        WrongLimit = 15
        NoGainSwap = 16
        PositionDoesNotExist = 17
        FeeTierAlreadyExist = 18
        PoolDoesNotExist = 19
        PoolAlreadyExist = 20
        TickAlreadyExist = 21
        InvalidTickIndex = 22
        TickAndTickSpacingMismatch = 23
        LimitReached = 24
        ChunkNotFound = 25
        TickInitialized = 26
    }

    @using(preapprovedAssets = false, updateFields = true)
    pub fn init() -> () {
        checkCaller!(callerAddress!() == config.admin, InvariantError.NotAdmin)
        assert!(!init, InvariantError.AlreadyInitialized)
        let invtId = selfAddress!()

        PositionsCounter(positionsCounterContractId).setAdmins(invtId)
        
        init = true
    }
    
    pub fn getProtocolFee() -> U256 {
        return config.protocolFee
    }

    @using(updateFields = true)
    pub fn changeProtocolFee(newProtocolFee: U256) -> () {
        checkCaller!(callerAddress!() == config.admin, InvariantError.NotAdmin)
        assert!(newProtocolFee < one(PercentageScale), InvariantError.InvalidProtocolFee)
        config.protocolFee = newProtocolFee
    }

    @using(assetsInContract = true)
    pub fn withdrawProtocolFee(token0: ByteVec, token1: ByteVec, fee: U256, tickSpacing: U256) -> () {
        let caller = callerAddress!()
        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)
        let (exist, pool) = wrappedGetPool(poolKey)
        assert!(exist, InvariantError.PoolDoesNotExist)

        let feeReceiver = pool.feeReceiver

        checkCaller!(feeReceiver == caller, InvariantError.NotFeeReceiver)

        let (feeProtocolTokenX, feeProtocolTokenY) = wrappedGetProtocolFee(poolKey)

        transferTokenFromSelf!(caller, pool.tokenX, feeProtocolTokenX)
        transferTokenFromSelf!(caller, pool.tokenY, feeProtocolTokenY)
    }

    pub fn changeFeeReceiver(token0: ByteVec, token1: ByteVec, fee: U256, tickSpacing: U256, newFeeReceiver: Address) -> () {
        let caller = callerAddress!()
        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)

        checkCaller!(config.admin == caller, InvariantError.NotAdmin)

        setFeeReceiver(poolKey, newFeeReceiver)
    }

    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn createPool(token0: ByteVec, token1: ByteVec, fee: U256, tickSpacing: U256, initSqrtPrice: U256, initTick: I256) -> () {
        assert!(init, InvariantError.NotInitialized)

        let feeTierExist = containsFeeTier(fee, tickSpacing)
        assert!(feeTierExist, InvariantError.FeeTierNotFound)

        clamm.checkTick(initTick, tickSpacing)

        assert!(token0 != token1, InvariantError.TokensAreSame)

        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)
        let (tokenX, tokenY) = extractTokensFromPoolKey(poolKey)
        
        let poolKeyExist = containsPoolKey(tokenX, tokenY, fee, tickSpacing)
        assert!(!poolKeyExist, InvariantError.PoolKeyAlreadyExist)

        assert!(clamm.checkTickToSqrtPriceRelationship(initTick, tickSpacing, initSqrtPrice), InvariantError.TickAndSqrtPriceMismatch)

        let caller = callerAddress!()
        let timestamp = blockTimeStamp!()
        let mapEntryDeposit = mapEntryDeposit!()
        addPoolKey{caller -> ALPH: mapEntryDeposit}(caller, tokenX, tokenY, fee, tickSpacing)
        addPool{caller -> ALPH: mapEntryDeposit}(caller, poolKey, tokenX, tokenY, tickSpacing, initSqrtPrice, initTick, timestamp, config.admin)
    }

    @using(preapprovedAssets = true)
    pub fn addFeeTier(fee: U256, tickSpacing: U256) -> () {
        assert!(init, InvariantError.NotInitialized)
        let caller = callerAddress!()
        checkCaller!(caller == config.admin, InvariantError.NotAdmin)

        assert!(tickSpacing > 0 || tickSpacing <= 100, InvariantError.InvalidTickSpacing)
        assert!(fee <= one(PercentageScale), InvariantError.InvalidFee)

        wrappedAddFeeTier{caller -> ALPH: mapEntryDeposit!()}(caller, fee, tickSpacing)
    }

    
    pub fn removeFeeTier(fee: U256, tickSpacing: U256) -> () {
        assert!(init, InvariantError.NotInitialized)
        let caller = callerAddress!()
        checkCaller!(caller == config.admin, InvariantError.NotAdmin)

        wrappedRemoveFeeTier(caller, fee, tickSpacing)
    }

    pub fn feeTierExist(fee: U256, tickSpacing: U256) -> Bool {
        return containsFeeTier(fee, tickSpacing)
    }

    pub fn getFeeTiers() -> ByteVec {
        return getAllFeeTiers()
    }

    pub fn getPools() -> ByteVec {
        return getAllPoolKeys()
    }

    pub fn getTick(token0: ByteVec, token1: ByteVec, fee: U256, tickSpacing: U256, index: I256) -> (Bool, Tick) {
        return wrappedGetTick(generatePoolKey(token0, token1, fee, tickSpacing), index)
    }

    pub fn getPool(token0: ByteVec, token1: ByteVec, fee: U256, tickSpacing: U256) -> (Bool, Pool) {
        return wrappedGetPool(generatePoolKey(token0, token1, fee, tickSpacing))
    }

    pub fn getPosition(index: U256) -> (Bool, PositionState) {
        let subContractId = subContractId!(toByteVec!(index))

        if (!contractExists!(subContractId)) {
            return false,
            PositionState {
                poolKey: #,
                liquidity: 0,
                lowerTickIndex: 0i,
                upperTickIndex: 0i,
                feeGrowthInsideX: 0,
                feeGrowthInsideY: 0,
                lastBlockNumber: 0,
                tokensOwedX: 0,
                tokensOwedY: 0,
                owner: byteVecToAddress!(#)
            }
        } else {
            return true, Position(subContractId).get()
        }
    }

    @using(preapprovedAssets = true)
    fn addPosition(
        originalCaller: Address,
        poolKey: ByteVec,
        liquidity: U256,
        lowerTickIndex: I256,
        upperTickIndex: I256,
        feeGrowthInsideX: U256,
        feeGrowthInsideY: U256,
        lastBlockNumber: U256,
        tokensOwedX: U256,
        tokensOwedY: U256
    ) -> () {
        let positionsCounter = PositionsCounter(positionsCounterContractId)
        let length = positionsCounter.get()
        positionsCounter.set(length + 1)

        let (encodedImmFields, encodedMutFields) = Position.encodeFields!(
            selfAddress!(),
            PositionState {
                poolKey: poolKey,
                liquidity: liquidity,
                lowerTickIndex: lowerTickIndex,
                upperTickIndex: upperTickIndex,
                feeGrowthInsideX: feeGrowthInsideX,
                feeGrowthInsideY: feeGrowthInsideY,
                lastBlockNumber: lastBlockNumber,
                tokensOwedX: tokensOwedX,
                tokensOwedY: tokensOwedY,
                owner: originalCaller
            },
            true,
            clamm
        )
        let _ = copyCreateSubContract!{originalCaller -> ALPH: mapEntryDeposit!()}(
            toByteVec!(length + 1),
            positionTemplateContractId,
            encodedImmFields,
            encodedMutFields
        )
    }

    pub fn isTickInitialized(token0: ByteVec, token1: ByteVec, fee: U256, tickSpacing: U256, index: I256) -> Bool {
        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)

        return getBit(index, tickSpacing, poolKey)
    }

    @using(preapprovedAssets = true)
    fn createTick(
        caller: Address,
        poolKey: ByteVec,
        tickSpacing: U256,
        index: I256,
        currentTickIndex: I256,
        feeGrowthGlobalX: U256,
        feeGrowthGlobalY: U256,
        startTimestamp: U256
    ) -> () {
        clamm.checkTick(index, tickSpacing)

        let mut feeGrowthOutsideX = 0
        let mut feeGrowthOutsideY = 0
        let mut secondsOutside = 0

        if (index <= currentTickIndex) {
            feeGrowthOutsideX = feeGrowthGlobalX
            feeGrowthOutsideY = feeGrowthGlobalY
            secondsOutside = blockTimeStamp!() - startTimestamp
        }

        wrappedCreateTick{caller -> ALPH: mapEntryDeposit!()}(
            caller,
            poolKey,
            index,
            true,
            0,
            0,
            clamm.calculateSqrtPrice(index),
            feeGrowthOutsideX,
            feeGrowthOutsideY, 
            0
        )
    }

    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn initializeEmptyPosition(
        token0: ByteVec,
        token1: ByteVec,
        fee: U256,
        tickSpacing: U256,
        lowerTick: I256,
        upperTick: I256
    ) -> () {
        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)
        let (exist, pool) = wrappedGetPool(poolKey)
        assert!(exist, InvariantError.PoolDoesNotExist)

        let currentTickindex = pool.currentTickIndex
        let feeGrowthGlobalX = pool.feeGrowthGlobalX
        let feeGrowthGlobalY = pool.feeGrowthGlobalY
        let startTimestamp = pool.startTimestamp

        let caller = callerAddress!()

        let (lowerChunk, upperChunk) = getChunks(lowerTick, upperTick, tickSpacing)

        let mapEntryDeposit = mapEntryDeposit!()
        if (lowerChunk == upperChunk) {
            initializeChunk{caller -> ALPH: mapEntryDeposit}(caller, poolKey, lowerChunk)
        } else {
            initializeChunk{caller -> ALPH: mapEntryDeposit}(caller, poolKey, lowerChunk)
            initializeChunk{caller -> ALPH: mapEntryDeposit}(caller, poolKey, upperChunk)
        }
        
        let mapEntry2Deposits = mapEntryDeposit * 2
        if (!containsTick(poolKey, lowerTick)) {
            createTick{caller -> ALPH: mapEntry2Deposits}(caller, poolKey, tickSpacing, lowerTick, currentTickindex, feeGrowthGlobalX, feeGrowthGlobalY, startTimestamp)
        }

        if (!containsTick(poolKey, upperTick)) {
            createTick{caller -> ALPH: mapEntry2Deposits}(caller, poolKey, tickSpacing, upperTick, currentTickindex, feeGrowthGlobalX, feeGrowthGlobalY, startTimestamp)
        }

        addPosition{caller -> ALPH: mapEntry2Deposits}(caller, poolKey, 0, lowerTick, upperTick, 0, 0, blockTimeStamp!(), 0, 0)
    }

    @using(preapprovedAssets = true, assetsInContract = true, checkExternalCaller = false)
    pub fn increasePositionLiquidity(
        index: U256,
        token0: ByteVec,
        token1: ByteVec,
        fee: U256,
        tickSpacing: U256,
        lowerTick: I256,
        upperTick: I256,
        liquidityDelta: U256,
        slippageLimitLower: U256,
        slippageLimitUpper: U256
    ) -> () {
        let currentTimestamp = blockTimeStamp!()

        assert!(liquidityDelta != 0, InvariantError.ZeroLiquidity)

        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)

        let (exist, pool) = wrappedGetPool(poolKey)
        assert!(exist, InvariantError.PoolDoesNotExist)

        if (isTickInitialized(token0, token1, fee, tickSpacing, lowerTick) == false) {
            flip(true, lowerTick, tickSpacing, poolKey)
        }
        
        if (isTickInitialized(token0, token1, fee, tickSpacing, upperTick) == false) {
            flip(true, upperTick, tickSpacing, poolKey)
        }

        let poolSqrtPrice = pool.sqrtPrice

        assert!(poolSqrtPrice >= slippageLimitLower && poolSqrtPrice <= slippageLimitUpper, InvariantError.PriceLimitReached)

        let (x, y) = wrappedModifyPosition(callerAddress!(), index,poolKey, upperTick, lowerTick, liquidityDelta, true, currentTimestamp, tickSpacing)

        transferTokenToSelf!(callerAddress!(), pool.tokenX, x)
        transferTokenToSelf!(callerAddress!(), pool.tokenY, y)
    }

    fn wrappedModifyPosition(
        originalCaller: Address,
        index: U256,
        poolKey: ByteVec,
        upperTick: I256,
        lowerTick: I256,
        liquidityDelta: U256,
        add: Bool,
        currentTimestamp: U256,
        tickSpacing: U256
    ) -> (U256, U256) {
        let position = Position(subContractId!(toByteVec!(index)))
        assert!(originalCaller == position.getOwner(), InvariantError.NotOwner)

        setLastTimestamp(poolKey, currentTimestamp)
        let (_, pool) = wrappedGetPool(poolKey)
        let maxLiquidityPerTick = clamm.calculateMaxLiquidityPerTick(tickSpacing)

        wrappedUpdateTick(poolKey, lowerTick, liquidityDelta, maxLiquidityPerTick, false, add)
        wrappedUpdateTick(poolKey, upperTick, liquidityDelta, maxLiquidityPerTick, true, add)

        let (lowerTickFeeGrowthOutsideX, lowerTickFeeGrowthOutsideY) = getTickFeeGrowthOutside(poolKey, lowerTick)
        let (upperTickFeeGrowthOutsideX, upperTickFeeGrowthOutsideY) = getTickFeeGrowthOutside(poolKey, upperTick)
        let poolCurrentTickIndex = pool.currentTickIndex
        let poolFeeGrowthGlobalX = pool.feeGrowthGlobalX
        let poolFeeGrowthGlobalY = pool.feeGrowthGlobalY

        position.modify(
            clamm,
            upperTick,
            upperTickFeeGrowthOutsideX,
            upperTickFeeGrowthOutsideY,
            lowerTick,
            lowerTickFeeGrowthOutsideX,
            lowerTickFeeGrowthOutsideY,
            poolCurrentTickIndex,
            poolFeeGrowthGlobalX,
            poolFeeGrowthGlobalY,
            liquidityDelta,
            add
        )

        return wrappedUpdateLiquidity(poolKey, liquidityDelta, add, upperTick, lowerTick)
    }

    @using(assetsInContract = true, checkExternalCaller = false)
    pub fn removePosition(index: U256) -> () {
        let caller = callerAddress!()

        let subContractId = subContractId!(toByteVec!(index))
        assert!(contractExists!(subContractId), InvariantError.PositionDoesNotExist)
        let position = Position(subContractId)

        let owner = position.getOwner()
        assert!(caller == owner, InvariantError.NotOwner)

        let poolKey = position.getPoolKey()
        let upperTick = position.getUpperTickIndex()
        let lowerTick = position.getLowerTickIndex()
        let liquidity = position.getLiquidity()

        let (_, pool) = wrappedGetPool(poolKey)
        let tickSpacing = pool.tickSpacing

        let (mut x, mut y) = wrappedModifyPosition(callerAddress!(), index, poolKey, upperTick, lowerTick, liquidity, false, blockTimeStamp!(), tickSpacing)

        let tokensOwedX = position.getTokensOwedX()
        let tokensOwedY = position.getTokensOwedY()

        x = x + tokensOwedX
        y = y + tokensOwedY

        transferTokenFromSelf!(caller, pool.tokenX, x)
        transferTokenFromSelf!(caller, pool.tokenY, y)

        position.remove()
    }

    @using(checkExternalCaller = false)
    pub fn transferPosition(index: U256, newOwner: Address) -> () {
        let caller = callerAddress!()

        let subContractId = subContractId!(toByteVec!(index))
        assert!(contractExists!(subContractId), InvariantError.PositionDoesNotExist)
        let position = Position(subContractId)
        let owner = position.getOwner()
        assert!(caller == owner, InvariantError.NotOwner)
        
        position.setOwner(newOwner)
    }

    @using(checkExternalCaller = false)
    pub fn quote(
        token0: ByteVec,
        token1: ByteVec,
        fee: U256,
        tickSpacing: U256,
        xToY: Bool,
        amount: U256,
        byAmountIn: Bool,
        sqrtPriceLimit: U256
    ) -> QuoteResult {
        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)
        let calculateSwapResult = calculateSwap(poolKey, xToY, amount, byAmountIn, sqrtPriceLimit, fee, tickSpacing)

        return QuoteResult { 
            amountIn: calculateSwapResult.amountIn,
            amountOut: calculateSwapResult.amountOut,
            targetSqrtPrice: calculateSwapResult.targetSqrtPrice
        }
    }

    fn calculateSwap(
        poolKey: ByteVec,
        xToY: Bool,
        amount: U256,
        byAmountIn: Bool,
        sqrtPriceLimit: U256,
        fee: U256,
        tickSpacing: U256
    ) -> CalculateSwapResult {
        let currentTimestamp = blockTimeStamp!()

        assert!(amount != 0, InvariantError.ZeroAmount)
        let (exist, mut pool) = wrappedGetPool(poolKey)
        assert!(exist, InvariantError.PoolDoesNotExist)
        
        let mut sqrtPrice = pool.sqrtPrice

        if (xToY) {
            assert!(sqrtPrice > sqrtPriceLimit && sqrtPriceLimit <= MaxSqrtPrice, InvariantError.WrongLimit)             
        } else {
            assert!(sqrtPrice < sqrtPriceLimit && sqrtPriceLimit >= MinSqrtPrice, InvariantError.WrongLimit)
        }

        let mut totalAmountIn = 0
        let mut totalAmountOut = 0
        let mut eventFeeAmount = 0
        let mut remainingAmount = amount
        let eventStartSqrtPrice = sqrtPrice

        while (remainingAmount != 0) {
            // TODO: reduce saving and getting pool from mapping
            let (_, wPool) = wrappedGetPool(poolKey)
            pool = wPool
            let currentTickIndex = pool.currentTickIndex
            let liquidity = pool.liquidity
            sqrtPrice = pool.sqrtPrice

            let (swapLimit, hasLimitingTick, limitingTickIndex, isInitialized) = getCloserLimit(
                sqrtPriceLimit,
                xToY,
                currentTickIndex,
                tickSpacing,
                poolKey
            )

            let swapResult = clamm.computeSwapStep(
                sqrtPrice,
                swapLimit,
                liquidity,
                remainingAmount,
                byAmountIn,
                fee
            )

            if (byAmountIn) {
                remainingAmount = remainingAmount - (swapResult.amountIn + swapResult.feeAmount)
            } else {
                remainingAmount = remainingAmount - swapResult.amountOut
            }

            wrappedAddFee(poolKey, swapResult.feeAmount, xToY, config.protocolFee)
            setSqrtPrice(poolKey, swapResult.nextSqrtPrice)

            totalAmountIn = totalAmountIn + swapResult.amountIn + swapResult.feeAmount
            totalAmountOut = totalAmountOut + swapResult.amountOut
            eventFeeAmount = eventFeeAmount + swapResult.feeAmount

            assert!(swapResult.nextSqrtPrice != sqrtPriceLimit || remainingAmount == 0, InvariantError.PriceLimitReached)

            if (hasLimitingTick) {
                if (isInitialized) {
                    let (amountToAdd, updatedRemainingAmount, hasCrossed) = wrappedCrossTick(
                        poolKey,
                        swapResult.nextSqrtPrice,
                        swapLimit,
                        limitingTickIndex,
                        remainingAmount,
                        byAmountIn,
                        xToY,
                        config.protocolFee,
                        fee,
                        tickSpacing
                    )
                    remainingAmount = updatedRemainingAmount
                    totalAmountIn = totalAmountIn + amountToAdd
                    if (hasCrossed) {
                        let (_, crossedPool) = wrappedGetPool(poolKey)
                        let feeGrowthGlobalX = crossedPool.feeGrowthGlobalX
                        let feeGrowthGlobalY = crossedPool.feeGrowthGlobalY
                        let (add, liquidityDelta) = wrappedCross(poolKey, limitingTickIndex, feeGrowthGlobalX, feeGrowthGlobalY, currentTickIndex)
                        wrappedCrossLiquidityUpdate(poolKey, add, liquidityDelta)
                    }
                }
            } else {
                let newTickIndex = clamm.getTickAtSqrtPrice(swapResult.nextSqrtPrice, tickSpacing)
                setCurrentTickIndex(poolKey, newTickIndex)
                setLastTimestamp(poolKey, currentTimestamp)
            }
        }
        assert!(totalAmountOut != 0, InvariantError.NoGainSwap)

        let (_, updatedPool) = wrappedGetPool(poolKey)
        return CalculateSwapResult {
            amountIn: totalAmountIn,
            amountOut: totalAmountOut,
            startSqrtPrice: eventStartSqrtPrice,
            targetSqrtPrice: updatedPool.sqrtPrice,
            fee: eventFeeAmount
        }
    }

    @using(assetsInContract = true, preapprovedAssets = true, checkExternalCaller = false)
    pub fn swap(
        token0: ByteVec,
        token1: ByteVec,
        fee: U256,
        tickSpacing: U256,
        xToY: Bool,
        amount: U256,
        byAmountIn: Bool,
        sqrtPriceLimit: U256
    ) -> CalculateSwapResult {
        let caller = callerAddress!()
        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)

        let calculateSwapResult = calculateSwap(poolKey, xToY, amount, byAmountIn, sqrtPriceLimit, fee, tickSpacing)

        let (_, pool) = wrappedGetPool(poolKey)
        let tokenX = pool.tokenX
        let tokenY = pool.tokenY

        if (xToY) {
            transferTokenToSelf!(caller, tokenX, calculateSwapResult.amountIn)
            transferTokenFromSelf!(caller, tokenY, calculateSwapResult.amountOut)
        } else {
            transferTokenFromSelf!(caller, tokenX, calculateSwapResult.amountOut)
            transferTokenToSelf!(caller, tokenY, calculateSwapResult.amountIn)
        }

        return calculateSwapResult
    }
    
    @using(assetsInContract = true, checkExternalCaller = false)
    pub fn claimFee(index: U256) -> () {
        let caller = callerAddress!()

        let subContractId = subContractId!(toByteVec!(index))
        assert!(contractExists!(subContractId), InvariantError.PositionDoesNotExist)
        let position = Position(subContractId)

        let poolKey = position.getPoolKey()
        let (exist, pool) = wrappedGetPool(poolKey)
        assert!(exist, InvariantError.PoolDoesNotExist)

        let upperTick = position.getUpperTickIndex()
        let lowerTick = position.getLowerTickIndex()
        let tickSpacing = pool.tickSpacing

        let (_, _) = wrappedModifyPosition(caller, index, poolKey, upperTick, lowerTick, 0, false, blockTimeStamp!(), tickSpacing)
        
        let tokensOwedX = position.getTokensOwedX()
        let tokensOwedY = position.getTokensOwedY()

        position.setTokensOwedX(0)
        position.setTokensOwedY(0)

        let tokenX = pool.tokenX
        let tokenY = pool.tokenY

        transferTokenFromSelf!(caller, tokenX, tokensOwedX)
        transferTokenFromSelf!(caller, tokenY, tokensOwedY)
    }
}
