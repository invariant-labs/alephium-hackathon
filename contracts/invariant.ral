Contract Invariant(
    admin: Address,
    protocolFee: U256,
    feeTierTemplateContractId: ByteVec,
    mut feeTierCount: U256,
    poolKeyTemplateContractId: ByteVec,
    mut poolKeyCount: U256,
    poolTemplateContractId: ByteVec
) extends FeeTiers(feeTierTemplateContractId, feeTierCount), PoolKeys(poolKeyTemplateContractId, poolKeyCount), Pools(poolTemplateContractId), CLAMM(), CollectionsPrefixes() {
    pub fn getProtocolFee() -> U256 {
        return protocolFee
    }

    // @using(updateFields = true, checkExternalCaller = false)
    // pub fn createPool(token0: Address, token1: Address, fee: U256, tickSpacing: U256, initSqrtPrice: U256, initTick: I256) -> () {
    //     let caller = callerAddress!()
    //     let timestamp = blockTimeStamp!()

    //     assert!(feeTierContains(fee, tickSpacing), InvariantError.FeeTierNotFound)
    
    //     poolKeyCount = poolKeyCount + 1

    //     if (initTick + toI256!(tickSpacing) > getMaxTick(tickSpacing)) {
    //         let maxTick = getMaxTick(tickSpacing)
    //         let maxSqrtPrice = sqrtPriceFromTick(maxTick)
    //         assert!(initSqrtPrice == maxSqrtPrice, InvariantError.InvalidInitTick)
    //     } else {
    //         let lowerBound = sqrtPriceFromTick(initTick)
    //         let upperBound = sqrtPriceFromTick(initTick + toI256!(tickSpacing))
    //         assert!(initSqrtPrice < lowerBound && initSqrtPrice >= upperBound, InvariantError.InvalidInitTick)
    //     }
        
    //     let swappedPoolKeyExist = poolKeyExist(token1, token0, fee, tickSpacing)

    //     if (!swappedPoolKeyExist) {
    //         poolKeyExist = poolKeyExist(token0, token1, fee, tickSpacing)

    //         assert!(!poolKeyExist, InvariantError.PoolKeyExist)
    //     }

    //     let poolKey = PoolKey(subContractId!(toByteVec!(InvariantCollection.PoolKeys) ++ toByteVec!(poolKeyCount)))

    //     let (encodedImmFields, encodedMutFields) = Pool.encodeFields!(pool initSqrtPrice, initTick, 0, 0, 0, 0, timestamp, timestamp)
    //     copyCreateSubContract!{caller -> ALPH: 1 alph}(
    //         poolKey,
    //         poolTemplateContractId,
    //         encodedImmFields,
    //         encodedMutFields
    //     )
    // }

    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn addFeeTier(fee: U256, tickSpacing: U256) -> () {
        let caller = callerAddress!()

        assert!(tickSpacing > 0 || tickSpacing <= 100, InvariantError.InvalidTickSpacing)
        assert!(fee <= 1000000000000, InvariantError.InvalidFee)
        assert!(caller == admin, InvariantError.NotAdmin)

        feeTiersAdd{caller -> ALPH: 1 alph}(caller, fee, tickSpacing)
    }

    @using(checkExternalCaller = false)
    pub fn removeFeeTier(fee: U256, tickSpacing: U256) -> () {
        assert!(callerAddress!() == admin, InvariantError.NotAdmin)

        feeTiersRemove(fee, tickSpacing)
    }

    pub fn feeTierExist(fee: U256, tickSpacing: U256) -> Bool {
        return feeTiersContains(fee, tickSpacing)
    }

    // TODO: remove if possible after implementing get fee tiers
    pub fn getFeeTierCount() -> U256 {
        let mut count = 0

        for (let mut index = 1; index <= feeTierCount; index = index + 1) {
            let contract = FeeTier(subContractId!(toByteVec!(InvariantCollection.FeeTiers) ++ toByteVec!(index)))

            if (contract.isActive()) {
                count = count + 1
            }
        }

        return count
    }


    // TODO: implement
    pub fn getFeeTiers() -> () {}
}
