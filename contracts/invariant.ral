struct InvariantConfig { admin: Address, mut protocolFee: U256 }

Contract Invariant(
    mut init: Bool,
    mut config: InvariantConfig,
    feeTiersContractId: ByteVec,
    poolKeysContractId: ByteVec, 
    poolsContractId: ByteVec, 
    ticksContractId: ByteVec, 
    positionsContractId: ByteVec,
    tickmapContractId: ByteVec,
    swapContractId: ByteVec,
    clammContractId: ByteVec
) extends PoolKeyHelper(), Decimal() {
    enum InvariantError {
        NotAdmin = 0
        AlreadyInitialized = 1
        NotInitialized = 2
        InvalidTickSpacing = 3
        InvalidFee = 4
        FeeTierNotFound = 5
        TokensAreSame = 6
        PoolKeyAlreadyExist = 7
        TickAndSqrtPriceMismatch = 8
        NotFeeReceiver = 9
        ZeroLiquidity = 10
        PriceLimitReached = 11
        InvalidProtocolFee = 12
        NotOwner = 13
    }

    pub fn test() -> () {}

    @using(preapprovedAssets = false, updateFields = true)
    pub fn init() -> () {
        checkCaller!(callerAddress!() == config.admin, InvariantError.NotAdmin)
        assert!(!init, InvariantError.AlreadyInitialized)
        let invtId = selfAddress!()
        let positionsId = Positions(positionsContractId).getAddress()
        let swapId = SwapUtils(swapContractId).getSelfId()

        FeeTiers(feeTiersContractId).setAdmins(invtId)
        PoolKeys(poolKeysContractId).setAdmins(invtId)
        Pools(poolsContractId).setAdmins(invtId, positionsId, swapId)
        Positions(positionsContractId).setAdmins(invtId)
        Tickmap(tickmapContractId).setAdmins(invtId, swapId)
        Ticks(ticksContractId).setAdmins(invtId, positionsId, swapId)
        
        init = true
    }
    
    pub fn getProtocolFee() -> U256 {
        return config.protocolFee
    }

    @using(updateFields = true)
    pub fn changeProtocolFee(newProtocolFee: U256) -> () {
        checkCaller!(callerAddress!() == config.admin, InvariantError.NotAdmin)
        assert!(newProtocolFee < one(PercentageScale), InvariantError.InvalidProtocolFee)
        config.protocolFee = newProtocolFee
    }

    @using(assetsInContract = true)
    pub fn withdrawProtocolFee(token0: ByteVec, token1: ByteVec, fee: U256, tickSpacing: U256) -> () {
        let caller = callerAddress!()
        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)
        let feeReceiver = Pools(poolsContractId).getFeeReceiver(poolKey)

        checkCaller!(feeReceiver == caller, InvariantError.NotFeeReceiver)

        let (feeProtocolTokenX, feeProtocolTokenY) = Pools(poolsContractId).wrappedWithdrawProtocolFee(poolKey)

        let (tokenX, tokenY) = Pools(poolsContractId).getToken(poolKey)

        transferTokenFromSelf!(caller, tokenX, feeProtocolTokenX)
        transferTokenFromSelf!(caller, tokenY, feeProtocolTokenY)
    }

    pub fn changeFeeReceiver(token0: ByteVec, token1: ByteVec, fee: U256, tickSpacing: U256, newFeeReceiver: Address) -> () {
        let caller = callerAddress!()
        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)

        checkCaller!(config.admin == caller, InvariantError.NotAdmin)

        Pools(poolsContractId).setFeeReceiver(poolKey, newFeeReceiver)
    }

    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn createPool(token0: ByteVec, token1: ByteVec, fee: U256, tickSpacing: U256, initSqrtPrice: U256, initTick: I256) -> () {
        assert!(init, InvariantError.NotInitialized)

        let feeTierExist = FeeTiers(feeTiersContractId).contains(fee, tickSpacing)
        assert!(feeTierExist, InvariantError.FeeTierNotFound)

        CLAMM(clammContractId).checkTick(initTick, tickSpacing)

        assert!(token0 != token1, InvariantError.TokensAreSame)

        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)
        let (tokenX, tokenY) = extractTokensFromPoolKey(poolKey)
        
        let poolKeyExist = PoolKeys(poolKeysContractId).contains(tokenX, tokenY, fee, tickSpacing)
        assert!(!poolKeyExist, InvariantError.PoolKeyAlreadyExist)

        assert!(CLAMM(clammContractId).checkTickToSqrtPriceRelationship(initTick, tickSpacing, initSqrtPrice), InvariantError.TickAndSqrtPriceMismatch)

        let caller = callerAddress!()
        let timestamp = blockTimeStamp!()
        PoolKeys(poolKeysContractId).add{caller -> ALPH: 1 alph}(caller, tokenX, tokenY, fee, tickSpacing)
        Pools(poolsContractId).add{caller -> ALPH: 1 alph}(caller, poolKey, tokenX, tokenY, tickSpacing, initSqrtPrice, initTick, timestamp, config.admin)
    }

    @using(preapprovedAssets = true)
    pub fn addFeeTier(fee: U256, tickSpacing: U256) -> () {
        assert!(init, InvariantError.NotInitialized)
        let caller = callerAddress!()
        checkCaller!(caller == config.admin, InvariantError.NotAdmin)

        assert!(tickSpacing > 0 || tickSpacing <= 100, InvariantError.InvalidTickSpacing)
        assert!(fee <= one(PercentageScale), InvariantError.InvalidFee)

        FeeTiers(feeTiersContractId).add{caller -> ALPH: 1 alph}(caller, fee, tickSpacing)
    }

    pub fn removeFeeTier(fee: U256, tickSpacing: U256) -> () {
        assert!(init, InvariantError.NotInitialized)
        checkCaller!(callerAddress!() == config.admin, InvariantError.NotAdmin)

        FeeTiers(feeTiersContractId).remove(fee, tickSpacing)
    }

    pub fn feeTierExist(fee: U256, tickSpacing: U256) -> Bool {
        return FeeTiers(feeTiersContractId).contains(fee, tickSpacing)
    }

    pub fn getFeeTiers() -> ByteVec {
        return FeeTiers(feeTiersContractId).getAll()
    }

    pub fn getPools() -> ByteVec {
        return PoolKeys(poolKeysContractId).getAll()
    }

    pub fn getTick(token0: ByteVec, token1: ByteVec, fee: U256, tickSpacing: U256, index: I256) -> (Bool, Bool, U256, U256, U256, U256, U256, U256) {
        return Ticks(ticksContractId).get(generatePoolKey(token0, token1, fee, tickSpacing), index)
    }

    pub fn getPool(token0: ByteVec, token1: ByteVec, fee: U256, tickSpacing: U256) -> (Bool, U256, U256, I256, U256, U256, U256, U256, U256, U256, Address) {
        return Pools(poolsContractId).get(generatePoolKey(token0, token1, fee, tickSpacing))
    }

    pub fn getPosition(index: U256) -> (Bool, U256, I256, I256, U256, U256, U256, U256, U256, Address) {
        return Positions(positionsContractId).get(index)
    }

    pub fn isTickInitialized(token0: ByteVec, token1: ByteVec, fee: U256, tickSpacing: U256, index: I256) -> Bool {
        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)

        return Tickmap(tickmapContractId).get(index, tickSpacing, poolKey)
    }

    @using(preapprovedAssets = true)
    fn createTick(
        caller: Address,
        poolKey: ByteVec,
        tickSpacing: U256,
        index: I256,
        currentTickIndex: I256,
        feeGrowthGlobalX: U256,
        feeGrowthGlobalY: U256,
        startTimestamp: U256
    ) -> () {
        CLAMM(clammContractId).checkTick(index, tickSpacing)

        let mut feeGrowthOutsideX = 0
        let mut feeGrowthOutsideY = 0
        let mut secondsOutside = 0

        if (index <= currentTickIndex) {
            feeGrowthOutsideX = feeGrowthGlobalX
            feeGrowthOutsideY = feeGrowthGlobalY
            secondsOutside = blockTimeStamp!() - startTimestamp
        }

        Ticks(ticksContractId).add{caller -> ALPH: 1 alph}(
            caller,
            poolKey,
            index,
            true,
            0,
            0,
            CLAMM(clammContractId).calculateSqrtPrice(index),
            feeGrowthOutsideX,
            feeGrowthOutsideY, 
            0
        )
    }

    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn initializeEmptyPosition(
        token0: ByteVec,
        token1: ByteVec,
        fee: U256,
        tickSpacing: U256,
        lowerTick: I256,
        upperTick: I256
    ) -> () {
        let pools = Pools(poolsContractId) 
        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)

        let currentTickindex = pools.getCurrentTickIndex(poolKey)
        let (feeGrowthGlobalX, feeGrowthGlobalY) = pools.getFeeGrowthGlobal(poolKey)
        let startTimestamp = pools.getStartTimestamp(poolKey)

        let ticks = Ticks(ticksContractId)
        let caller = callerAddress!()

        let (lowerChunk, upperChunk) = Tickmap(tickmapContractId).getChunks(lowerTick, upperTick, tickSpacing)

        if (lowerChunk == upperChunk) {
            Tickmap(tickmapContractId).initializeChunk{caller -> ALPH: 1 alph}(caller, poolKey, lowerChunk)
        } else {
            Tickmap(tickmapContractId).initializeChunk{caller -> ALPH: 1 alph}(caller, poolKey, lowerChunk)
            Tickmap(tickmapContractId).initializeChunk{caller -> ALPH: 1 alph}(caller, poolKey, upperChunk)
        }
 
        if(!ticks.contains(poolKey, lowerTick)) {
            createTick{caller -> ALPH: 2 alph}(caller, poolKey, tickSpacing, lowerTick, currentTickindex, feeGrowthGlobalX, feeGrowthGlobalY, startTimestamp)
        }

        if(!ticks.contains(poolKey, upperTick)) {
            createTick{caller -> ALPH: 2 alph}(caller, poolKey, tickSpacing, upperTick, currentTickindex, feeGrowthGlobalX, feeGrowthGlobalY, startTimestamp)
        }

        Positions(positionsContractId).add{caller -> ALPH: 2 alph}(caller, poolKey, 0, lowerTick, upperTick, 0, 0, blockTimeStamp!(), 0, 0)
    }

    @using(preapprovedAssets = true, assetsInContract = true, checkExternalCaller = false)
    pub fn increasePositionLiquidity(
        index: U256,
        token0: ByteVec,
        token1: ByteVec,
        fee: U256,
        tickSpacing: U256,
        lowerTick: I256,
        upperTick: I256,
        liquidityDelta: U256,
        slippageLimitLower: U256,
        slippageLimitUpper: U256
    ) -> () {
        let pools = Pools(poolsContractId)
        let currentTimestamp = blockTimeStamp!()

        assert!(liquidityDelta != 0, InvariantError.ZeroLiquidity)

        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)

        if(isTickInitialized(token0, token1, fee, tickSpacing, lowerTick) == false) {
            Tickmap(tickmapContractId).flip(true, lowerTick, tickSpacing, poolKey)
        }
        
        if(isTickInitialized(token0, token1, fee, tickSpacing, upperTick) == false) {
            Tickmap(tickmapContractId).flip(true, upperTick, tickSpacing, poolKey)
        }

        let poolSqrtPrice = pools.getSqrtPrice(poolKey)

        assert!(poolSqrtPrice >= slippageLimitLower && poolSqrtPrice <= slippageLimitUpper, InvariantError.PriceLimitReached)

        let (x, y) = Positions(positionsContractId).wrappedModify(callerAddress!(), index, poolsContractId, ticksContractId, clammContractId,  poolKey, upperTick, lowerTick, liquidityDelta, true, currentTimestamp, tickSpacing)

        let (tokenX, tokenY) = pools.getToken(poolKey)

        transferTokenToSelf!(callerAddress!(), tokenX, x)
        transferTokenToSelf!(callerAddress!(), tokenY, y)
    }

    @using(assetsInContract = true, checkExternalCaller = false)
    pub fn removePosition(index: U256) -> () {
        let caller = callerAddress!()
        let positions = Positions(positionsContractId)

        let owner = positions.getOwner(index)
        assert!(caller == owner, InvariantError.NotOwner)

        let poolKey = positions.getPoolKey(index)
        let upperTick = positions.getUpperTickIndex(index)
        let lowerTick = positions.getLowerTickIndex(index)
        let liquidity = positions.getLiquidity(index)

        let tickSpacing = Pools(poolsContractId).getTickSpacing(poolKey)

        let (mut x, mut y) = Positions(positionsContractId).wrappedModify(callerAddress!(), index, poolsContractId, ticksContractId, clammContractId,  poolKey, upperTick, lowerTick, liquidity, false, blockTimeStamp!(), tickSpacing)

        let pools = Pools(poolsContractId)

        let (tokenX, tokenY) = pools.getToken(poolKey)
        let tokensOwedX = positions.getTokensOwedX(index)
        let tokensOwedY = positions.getTokensOwedY(index)

        positions.remove(index)

        x = x + tokensOwedX
        y = y + tokensOwedY

        transferTokenFromSelf!(caller, tokenX, x)
        transferTokenFromSelf!(caller, tokenY, y)
    }

    @using(checkExternalCaller = false)
    pub fn transferPosition(index: U256, newOwner: Address) -> () {
        let caller = callerAddress!()
        let positions = Positions(positionsContractId)

        let owner = positions.getOwner(index)
        assert!(caller == owner, InvariantError.NotOwner)

        Positions(positionsContractId).transfer(index, newOwner)
    }

    @using(checkExternalCaller = false)
    pub fn quote(
        token0: ByteVec,
        token1: ByteVec,
        fee: U256,
        tickSpacing: U256,
        xToY: Bool,
        amount: U256,
        byAmountIn: Bool,
        sqrtPriceLimit: U256
    ) -> (U256, U256, U256) {
        return SwapUtils(swapContractId).wrappedQuote(token0, token1, fee, tickSpacing, xToY, amount, byAmountIn, sqrtPriceLimit)
    }

    @using(assetsInContract = true, preapprovedAssets = true, checkExternalCaller = false)
    pub fn swap(
        token0: ByteVec,
        token1: ByteVec,
        fee: U256,
        tickSpacing: U256,
        xToY: Bool,
        amount: U256,
        byAmountIn: Bool,
        sqrtPriceLimit: U256
    ) -> (U256, U256, U256, U256, U256) {
        let caller = callerAddress!()
        let poolKey = generatePoolKey(token0, token1, fee, tickSpacing)

        let (amountIn, amountOut, startingSqrtPrice, targetSqrtPrice, feeAmount) = SwapUtils(swapContractId).wrappedSwap(token0, token1, fee, tickSpacing, xToY, amount, byAmountIn, sqrtPriceLimit)

        let (tokenX, tokenY) = Pools(poolsContractId).getToken(poolKey)

        if (xToY) {
            transferTokenToSelf!(caller, tokenX, amountIn)
            transferTokenFromSelf!(caller, tokenY, amountOut)
        } else {
            transferTokenFromSelf!(caller, tokenX, amountOut)
            transferTokenToSelf!(caller, tokenY, amountIn)
        }

        return amountIn, amountOut, startingSqrtPrice, targetSqrtPrice, feeAmount
    }
    
    @using(assetsInContract = true, checkExternalCaller = false)
    pub fn claimFee(index: U256) -> () {
        let caller = callerAddress!()
        let positions = Positions(positionsContractId)
        let pools = Pools(poolsContractId)

        let poolKey = positions.getPoolKey(index)
        let upperTick = positions.getUpperTickIndex(index)
        let lowerTick = positions.getLowerTickIndex(index)
        let tickSpacing = pools.getTickSpacing(poolKey)

        let (_, _) = positions.wrappedModify(callerAddress!(), index, poolsContractId, ticksContractId, clammContractId,  poolKey, upperTick, lowerTick, 0, false, blockTimeStamp!(), tickSpacing)
        
        let tokensOwedX = positions.getTokensOwedX(index)
        let tokensOwedY = positions.getTokensOwedY(index)

        positions.setTokensOwedX(index, 0)
        positions.setTokensOwedY(index, 0)

        let (tokenX, tokenY) = pools.getToken(poolKey)

        transferTokenFromSelf!(caller, tokenX, tokensOwedX)
        transferTokenFromSelf!(caller, tokenY, tokensOwedY)
    }
}
