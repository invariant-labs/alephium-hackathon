struct SingleTokenLiquidity {
    l: U256,
    amount: U256
}

Contract CLAMM() extends Uints(), Log(){ 
    enum CLAMMError {
        InvalidTickIndex = 800
        InvalidTickSpacing = 801
        UpperLTCurrentSqrtPrice = 802
        CurrentLTLowerSqrtPrice = 803
    }

    pub fn computeSwapStep(
        currentSqrtPrice: U256,
        targetSqrtPrice: U256,
        liquidity: U256,
        amount: U256,
        byAmountIn: Bool,
        fee: U256
    ) -> SwapResult {
        if (liquidity == 0) {
            return SwapResult { 
                nextSqrtPrice: targetSqrtPrice,
                amountIn: 0,
                amountOut: 0,
                feeAmount: 0
            }
        }

        let xToY = currentSqrtPrice >= targetSqrtPrice

        let mut nextSqrtPrice = 0
        let mut amountIn = 0
        let mut amountOut = 0

        if (byAmountIn) {
            let amountAfterFee = toU256(bigMulDiv256(amount, (one(PercentageScale) - fee), one(PercentageScale)))

            if (xToY) {
                amountIn = getDeltaX(targetSqrtPrice, currentSqrtPrice, liquidity, true)
            } else {
                amountIn = getDeltaY(currentSqrtPrice, targetSqrtPrice, liquidity, true)
            }

            if (amountAfterFee >= amountIn) {
                nextSqrtPrice = targetSqrtPrice
            } else {
                nextSqrtPrice = getNextSqrtPriceFromInput(currentSqrtPrice, liquidity, amountAfterFee, xToY)
            }
        } else {
            if (xToY) {
                amountOut = getDeltaY(targetSqrtPrice, currentSqrtPrice, liquidity, false)
            } else {
                amountOut = getDeltaX(currentSqrtPrice, targetSqrtPrice, liquidity, false)
            }

            if (amount >= amountOut) {
                nextSqrtPrice = targetSqrtPrice
            } else {
                nextSqrtPrice = getNextSqrtPriceFromOutput(currentSqrtPrice, liquidity, amount, xToY)
            }
        }

        let notMax = targetSqrtPrice != nextSqrtPrice

        if (xToY) {
            if (notMax || !byAmountIn) {
                amountIn = getDeltaX(nextSqrtPrice, currentSqrtPrice, liquidity, true)
            }
            if (notMax || byAmountIn) {
                amountOut = getDeltaY(nextSqrtPrice, currentSqrtPrice, liquidity, false)
            }
        } else {
            if (notMax|| !byAmountIn) {
                amountIn = getDeltaY(currentSqrtPrice, nextSqrtPrice, liquidity, true)
            }
            if (notMax || byAmountIn) {
                amountOut = getDeltaX(currentSqrtPrice, nextSqrtPrice, liquidity, false)
            }
        }

        // trim dust in case of specifying exact amount out
        if (!byAmountIn && amountOut > amount) {
            amountOut = amount
        }

        let mut feeAmount = 0
        if (byAmountIn && nextSqrtPrice != targetSqrtPrice) {
            feeAmount = amount - amountIn
        } else {
            feeAmount = toU256(bigMulDivUp256(amountIn, fee, one(PercentageScale)))
        }

        return SwapResult { 
            nextSqrtPrice: nextSqrtPrice,
            amountIn: amountIn,
            amountOut: amountOut,
            feeAmount: feeAmount
        }
    }

    pub fn getDeltaX(
        sqrtPriceA: U256,
        sqrtPriceB: U256,
        liquidity: U256,
        roundingUp: Bool
    ) -> U256 {
        let mut deltaSqrtPrice = 0u
        if (sqrtPriceA > sqrtPriceB) {
            deltaSqrtPrice = sqrtPriceA - sqrtPriceB
        } else {
            deltaSqrtPrice = sqrtPriceB - sqrtPriceA
        }

        let nominator = bigMulDiv256(deltaSqrtPrice, liquidity, one(LiquidityScale))

        if (roundingUp) {
            let denominator = mul(sqrtPriceA, sqrtPriceB, one(SqrtPriceScale))
            return bigDivToTokenUp(nominator, denominator, one(SqrtPriceScale))
        } else {
            let denominatorUp = mulUp(sqrtPriceA, sqrtPriceB, one(SqrtPriceScale))
            return bigDivToToken(nominator, denominatorUp, one(SqrtPriceScale))
        }
    }

    pub fn getDeltaY(
        sqrtPriceA: U256,
        sqrtPriceB: U256,
        liquidity: U256,
        roundingUp: Bool
    ) -> U256 {
        let mut deltaSqrtPrice = 0u
        if (sqrtPriceA > sqrtPriceB) {
            deltaSqrtPrice = sqrtPriceA - sqrtPriceB
        } else {
            deltaSqrtPrice = sqrtPriceB - sqrtPriceA
        }

        let mut result = U512 { higher: 0, lower: 0 }

        if (roundingUp) {
            result = bigMulDiv256(deltaSqrtPrice, liquidity, one(LiquidityScale))
            result = bigAdd(result, almostOne(SqrtPriceScale))
            result = bigDiv(result, one(SqrtPriceScale), 1)

            return toU256(result)
        } else {
            result = bigMulDiv256(deltaSqrtPrice, liquidity, one(LiquidityScale))
            result = bigDiv(result, one(SqrtPriceScale), 1)

            return toU256(result)
        }
    }

    pub fn getNextSqrtPriceFromInput(
        startingSqrtPrice: U256,
        liquidity: U256,
        amount: U256,
        xToY: Bool
    ) -> U256 {
        if (xToY) {
            return getNextSqrtPriceXUp(startingSqrtPrice, liquidity, amount, true)
        } else {
            return getNextSqrtPriceYDown(startingSqrtPrice, liquidity, amount, true)
        } 
    }

    pub fn getNextSqrtPriceFromOutput(
        startingSqrtPrice: U256,
        liquidity: U256,
        amount: U256,
        xToY: Bool
    ) -> U256 {
        if (xToY) {
            return getNextSqrtPriceYDown(startingSqrtPrice, liquidity, amount, false)
        } else {
            return getNextSqrtPriceXUp(startingSqrtPrice, liquidity, amount, false)
        }
    }

    pub fn getNextSqrtPriceXUp(
        startingSqrtPrice: U256,
        liquidity: U256,
        x: U256,
        addX: Bool
    ) -> U256 {
        if (x == 0) {
            return startingSqrtPrice
        }

        let deltaSqrtPrice = bigRescale(liquidity, LiquidityScale, SqrtPriceScale)

        let mut denominator = U512 { higher: 0, lower: 0 }
        if (addX) {
            denominator = bigAdd512(deltaSqrtPrice, bigMulDiv256(startingSqrtPrice, x, one(TokenAmountScale)))
        } else {
            denominator = bigSub512(deltaSqrtPrice, bigMulDiv256(startingSqrtPrice, x, one(TokenAmountScale)))
        }

        let nominator = bigMulDivUp256(startingSqrtPrice, liquidity, one(LiquidityScale))

        let mut result = bigMul(nominator, one(SqrtPriceScale))
        result = bigAdd512(result, bigSub512(denominator, toU512(1)))
        result = bigDiv512(result, denominator, 1)

        return toU256(result)
    }

    pub fn getNextSqrtPriceYDown(
        startingSqrtPrice: U256,
        liquidity: U256,
        y: U256,
        addY: Bool
    ) -> U256 {
        let numerator = bigRescale(y, TokenAmountScale, SqrtPriceScale)
        let denominator = bigRescale(liquidity, LiquidityScale, SqrtPriceScale)
        
        if (addY) {
            return startingSqrtPrice + toU256(bigDiv512(numerator, denominator, one(SqrtPriceScale)))
        } else {
            return startingSqrtPrice - toU256(bigDivUp512(numerator, denominator, one(SqrtPriceScale)))
        }
    }

    pub fn calculateAmountDelta(
        currentTickIndex: I256,
        currentSqrtPrice: U256,
        liquidityDelta: U256,
        liquiditySign: Bool,
        upperTick: I256,
        lowerTick: I256
    ) -> (U256, U256, Bool) {
        assert!(upperTick > lowerTick, CLAMMError.InvalidTickIndex)

        let mut amountX = 0u
        let mut amountY = 0u
        let mut updateLiquidity = false

        if (currentTickIndex < lowerTick) {
            amountX = getDeltaX(
                sqrtPriceFromTick(lowerTick),
                sqrtPriceFromTick(upperTick),
                liquidityDelta,
                liquiditySign
            )
        } else if (currentTickIndex < upperTick) {
            amountX = getDeltaX(
                currentSqrtPrice,
                sqrtPriceFromTick(upperTick),
                liquidityDelta,
                liquiditySign
            )
            amountY = getDeltaY(
                sqrtPriceFromTick(lowerTick),
                currentSqrtPrice,
                liquidityDelta,
                liquiditySign
            )
            updateLiquidity = true
        } else {
            amountY = getDeltaY(
                sqrtPriceFromTick(lowerTick),
                sqrtPriceFromTick(upperTick),
                liquidityDelta,
                liquiditySign
            )
        }

        return amountX, amountY, updateLiquidity
    }

    pub fn isEnoughAmountToChangePrice(
        amount: U256,
        startingSqrtPrice: U256,
        liquidity: U256,
        fee: U256,
        byAmountIn: Bool,
        xToY: Bool
    ) -> Bool {
        if (liquidity == 0) {
            return true
        }

        let mut nextSqrtPrice = 0
        if (byAmountIn == true) {
            let amountAfterFee = toU256(bigMulDiv256(amount, (one(PercentageScale) - fee), PercentageScale))
            nextSqrtPrice = getNextSqrtPriceFromInput(startingSqrtPrice, liquidity, amountAfterFee, xToY)
        } else {
            nextSqrtPrice = getNextSqrtPriceFromOutput(startingSqrtPrice, liquidity, amount, xToY)
        }

        return startingSqrtPrice != nextSqrtPrice
    }

    pub fn calculateMaxLiquidityPerTick(
        tickSpacing: U256
    ) -> U256 {
        let maxTicksAmountSqrtPriceLimited = 2 * toU256!(getGlobalMaxTick()) + 1
        let ticksAmountSpacingLimited = maxTicksAmountSqrtPriceLimited / tickSpacing
        let maxLiquidity = u256Max!() / ticksAmountSpacingLimited
        return maxLiquidity
    }

    pub fn checkTicks(tickLower: I256, tickUpper: I256, tickSpacing: U256) -> () {
        assert!(tickLower < tickUpper, CLAMMError.InvalidTickIndex)
        checkTick(tickLower, tickSpacing)
        checkTick(tickUpper, tickSpacing)
    }

    pub fn checkTick(tickIndex: I256, tickSpacing: U256) -> () {
        let minTick = getMinTick(tickSpacing)
        let maxTick = getMaxTick(tickSpacing)
        assert!(tickIndex % toI256!(tickSpacing) == 0i, CLAMMError.InvalidTickSpacing)
        assert!(tickIndex < maxTick, CLAMMError.InvalidTickIndex)
        assert!(tickIndex > minTick, CLAMMError.InvalidTickIndex)
    }
    
    pub fn calculateMinAmountOut(
        expectedAmountOut: U256,
        slippage: U256
    ) -> U256 {
        return toU256(bigMulDivUp256(expectedAmountOut, (one(PercentageScale) - slippage), one(PercentageScale)))
    }

    pub fn checkTickToSqrtPriceRelationship(tickIndex: I256, tickSpacing: U256, sqrtPrice: U256) -> Bool {
        if (tickIndex + toI256!(tickSpacing) > getGlobalMaxTick()) {
            let maxTick = getMaxTick(tickSpacing)
            let maxSqrtPrice = sqrtPriceFromTick(maxTick)
            
            if (sqrtPrice != maxSqrtPrice) {
                return false
            }
        } else {
            let lowerBound = sqrtPriceFromTick(tickIndex)
            let upperBound = sqrtPriceFromTick(tickIndex + toI256!(tickSpacing))

            if (sqrtPrice >= upperBound || sqrtPrice < lowerBound) {
                return false
            }
        }

        return true
    }

    pub fn toFee(feeGrowth: U256, liquidity: U256) -> U256 {
        return toU256(bigMulDiv256(feeGrowth, liquidity, one(FeeGrowthScale + LiquidityScale)))
    }

    pub fn feeGrowthFromFee(liquidity: U256, fee: U256) -> U256 {
        return toU256(bigMulDiv256(fee, one(LiquidityScale + FeeGrowthScale), liquidity))
    }

    pub fn getLiquidityByX(x: U256, lowerTick: I256, upperTick: I256, currentSqrtPrice: U256, roundingUp: Bool) -> SingleTokenLiquidity {
        assert!(lowerTick >= GlobalMinTick && upperTick <= GlobalMaxTick, CLAMMError.InvalidTickIndex)
        let lowerSqrtPrice = calculateSqrtPrice(lowerTick)
        let upperSqrtPrice = calculateSqrtPrice(upperTick)

        return getLiquidityByXSqrtPrice(x, lowerSqrtPrice, upperSqrtPrice, currentSqrtPrice, roundingUp)
    }

    pub fn getLiquidityByXSqrtPrice(x: U256, lowerSqrtPrice: U256, upperSqrtPrice: U256, currentSqrtPrice: U256, roundingUp: Bool) -> SingleTokenLiquidity {
        assert!(upperSqrtPrice >= currentSqrtPrice, CLAMMError.UpperLTCurrentSqrtPrice)

        let mut nominator = U512 { higher: 0, lower: 0}
        let mut denominator = 0
        let mut liquidity = 0
        if (currentSqrtPrice < lowerSqrtPrice) {
            nominator = bigMulDiv256(lowerSqrtPrice, upperSqrtPrice, one(SqrtPriceScale))
            denominator = upperSqrtPrice - lowerSqrtPrice
            liquidity = toU256(bigDiv(bigMul(bigMul(nominator,x), one(LiquidityScale)), denominator, 1))
            return SingleTokenLiquidity { l: liquidity, amount: 0 }
        }

        nominator = bigMulDiv256(currentSqrtPrice, upperSqrtPrice, one(SqrtPriceScale))
        denominator = upperSqrtPrice - currentSqrtPrice
        liquidity = toU256(bigDiv(bigMul(bigMul(nominator,x), one(LiquidityScale)), denominator, 1))
        let sqrtPriceDiff = currentSqrtPrice - lowerSqrtPrice
        let y = calculateY(sqrtPriceDiff, liquidity, roundingUp)
        return SingleTokenLiquidity { l: liquidity, amount: y }
    }

    pub fn calculateY(sqrtPriceDiff: U256, liquidity: U256, roundingUp: Bool) -> U256 {
        let shiftedLiquidity = liquidity / one(LiquidityScale)
        if (roundingUp) {
            return (sqrtPriceDiff * shiftedLiquidity + almostOne(SqrtPriceScale)) / one(SqrtPriceScale)
        } else {
            return sqrtPriceDiff * shiftedLiquidity / one(SqrtPriceScale)
        }
    }

    pub fn getLiquidityByY(y: U256, lowerTick: I256, upperTick: I256, currentSqrtPrice: U256, roundingUp: Bool) -> SingleTokenLiquidity {
        assert!(lowerTick >= GlobalMinTick && upperTick <= GlobalMaxTick, CLAMMError.InvalidTickIndex)
        let lowerSqrtPrice = calculateSqrtPrice(lowerTick)
        let upperSqrtPrice = calculateSqrtPrice(upperTick)

        return getLiquidityByYSqrtPrice(y, lowerSqrtPrice, upperSqrtPrice, currentSqrtPrice, roundingUp)
    }

    pub fn getLiquidityByYSqrtPrice(y: U256, lowerSqrtPrice: U256, upperSqrtPrice: U256, currentSqrtPrice: U256, roundingUp: Bool) -> SingleTokenLiquidity {
        assert!(currentSqrtPrice >= lowerSqrtPrice, CLAMMError.CurrentLTLowerSqrtPrice)

        let mut sqrtPriceDiff = 0
        let mut liquidity = 0

        if (upperSqrtPrice <= currentSqrtPrice) {
            sqrtPriceDiff = upperSqrtPrice - lowerSqrtPrice
            liquidity = toU256(bigDiv(bigMul(bigMul256(y, one(SqrtPriceScale)), one(LiquidityScale)), sqrtPriceDiff, 1))
            return SingleTokenLiquidity { l: liquidity, amount: 0 }
        }

        sqrtPriceDiff = currentSqrtPrice - lowerSqrtPrice
        liquidity = toU256(bigDiv(bigMul(bigMul256(y, one(SqrtPriceScale)), one(LiquidityScale)), sqrtPriceDiff, 1))
        let denominator = (currentSqrtPrice * upperSqrtPrice )/ one(SqrtPriceScale)
        let nominator = upperSqrtPrice - currentSqrtPrice
        let x = calculateX(nominator, denominator, liquidity, roundingUp)
        return SingleTokenLiquidity { l: liquidity, amount: x }
    }

    pub fn calculateX(nominator: U256, denominator: U256, liquidity: U256, roundingUp: Bool) -> U256 {
        let common = bigMulDiv256(liquidity, nominator, denominator)
        if (roundingUp) {
            return toU256(bigDiv(bigAdd(common, almostOne(LiquidityScale)), one(LiquidityScale), 1))
        } else {
            return toU256(bigDiv(common, one(LiquidityScale), 1))
        }
        
    }
}