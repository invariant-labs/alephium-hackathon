Contract CLAMM() extends Decimal(){ 
    // pub fn compute_swap_step() {}
    pub fn getDeltaX(
        sqrtPriceA: U256,
        sqrtPriceB: U256,
        liquidity: U256,
        roundingUp: Bool
    ) -> U256 {
        let sqrtPriceScale = getSqrtPriceScale()
        let liquidityScale = getLiquidityScale()

        let mut deltaSqrtPrice = 0u
        if (sqrtPriceA > sqrtPriceB) {
            deltaSqrtPrice = sqrtPriceA - sqrtPriceB
        } else {
            deltaSqrtPrice = sqrtPriceB - sqrtPriceA
        }

        let nominator = mulToValue(deltaSqrtPrice, liquidity, liquidityScale)
        if (roundingUp == true) {
            return divValuesToTokenUp(
                    nominator,
                    mulToValue(sqrtPriceA, sqrtPriceB, sqrtPriceScale)
                )
        } else {
            return divValuesToToken(
                nominator,
                mulToValueUp(sqrtPriceA, sqrtPriceB, sqrtPriceScale)
            )
        }
    }
    pub fn getDeltaY(
        sqrtPriceA: U256,
        sqrtPriceB: U256,
        liquidity: U256,
        roundingUp: Bool
    ) -> U256 {
        let sqrtPriceScale = getSqrtPriceScale()
        let liquidityScale = getLiquidityScale()
        
        let mut deltaSqrtPrice = 0u
        if (sqrtPriceA > sqrtPriceB) {
            deltaSqrtPrice = sqrtPriceA - sqrtPriceB
        } else {
            deltaSqrtPrice = sqrtPriceB - sqrtPriceA
        }

        if (roundingUp == true) {
            return mulToValueUp(deltaSqrtPrice, liquidity, liquidityScale) + almostOne(sqrtPriceScale) / one(sqrtPriceScale)
        } else {
            return mulToValue(deltaSqrtPrice, liquidity, liquidityScale) / one(sqrtPriceScale)
        }
    }
    pub fn getNextSqrtPriceFromInput(
        startingSqrtPrice: U256,
        liquidity: U256,
        amount: U256,
        xToY: Bool
    ) -> U256 {
        if(xToY == true) {
            return getNextSqrtPriceXUp(startingSqrtPrice, liquidity, amount, true)
        } else {
            return getNextSqrtPriceYDown(startingSqrtPrice, liquidity, amount, true)
        } 
    }
    pub fn getNextSqrtPriceFromOutput(
        startingSqrtPrice: U256,
        liquidity: U256,
        amount: U256,
        xToY: Bool
    ) -> U256 {
        if(xToY == true) {
            return getNextSqrtPriceYDown(startingSqrtPrice, liquidity, amount, false)
        } else {
            return getNextSqrtPriceXUp(startingSqrtPrice, liquidity, amount, false)
        }
    }
    pub fn getNextSqrtPriceXUp(
        startingSqrtPrice: U256,
        liquidity: U256,
        x: U256,
        addX: Bool
    ) -> U256 {
        if (x == 0) {
            return startingSqrtPrice
        }

        let liquidityScale = getLiquidityScale()
        let sqrtPriceScale = getSqrtPriceScale()
        let tokenAmountScale = getTokenAmountScale()

        let deltaSqrtPrice = fromDecimalToValue(liquidity, liquidityScale, sqrtPriceScale)

        let mut denominator = 1
        if (addX == true) {
            denominator = deltaSqrtPrice + mulToValue(startingSqrtPrice, x, tokenAmountScale) 
        } else {
            denominator = deltaSqrtPrice - mulToValue(startingSqrtPrice, x, tokenAmountScale)
        }

        return divValuesToTokenUp(
            mulToValueUp(startingSqrtPrice, liquidity, liquidityScale),
            denominator
        )
    }
    pub fn getNextSqrtPriceYDown(
        startingSqrtPrice: U256,
        liquidity: U256,
        y: U256,
        addY: Bool
    ) -> U256 {
        let liquidityScale = getLiquidityScale()
        let sqrtPriceScale = getSqrtPriceScale()
        let tokenAmountScale = getTokenAmountScale()

        let numerator = fromDecimalToValue(y, tokenAmountScale, sqrtPriceScale)
        let denominator = fromDecimalToValue(liquidity, liquidityScale, sqrtPriceScale)

        if(addY == true) {
            return startingSqrtPrice + divValues(numerator, denominator)
        } else {
            return startingSqrtPrice - divValuesUp(numerator, denominator)
        }

    }
    pub fn calculateAmountDelta(
        currentTickIndex: I256,
        currentSqrtPrice: U256,
        liquidityDelta: U256,
        liquiditySign: Bool,
        upperTick: I256,
        lowerTick: I256
    ) -> (U256, U256, Bool) {
        
        // TODO: Add error enum, assert must return number instead of string
        // assert!(upperTick < lowerTick, "upperTick is not greater than lowerTick")

        let mut amountX = 0u
        let mut amountY = 0u
        let mut updateLiquidity = false

        if (currentTickIndex < lowerTick) {
            let sqrtPriceA = sqrtPriceFromTick(lowerTick)
            let sqrtPriceB = sqrtPriceFromTick(upperTick)
            amountX = getDeltaX(
                sqrtPriceA,
                sqrtPriceB,
                liquidityDelta,
                liquiditySign
            )
        } else if (currentTickIndex < upperTick) {
            amountX = getDeltaX(
                currentSqrtPrice,
                sqrtPriceFromTick(upperTick),
                liquidityDelta,
                liquiditySign
            )
            amountY = getDeltaY(
                sqrtPriceFromTick(lowerTick),
                currentSqrtPrice,
                liquidityDelta,
                liquiditySign
            )
            updateLiquidity = true
        } else {
            amountY = getDeltaY(
                sqrtPriceFromTick(lowerTick),
                sqrtPriceFromTick(upperTick),
                liquidityDelta,
                liquiditySign
            )
        }

        return amountX, amountY, updateLiquidity
    }
    
    // pub fn isEnoughToChangePrice(
    //     amount: U256,
    //     startingSqrtPrice: U256,
    //     liquidity: U256,
    //     fee: U256,
    //     byAmountIn: Bool,
    //     xToY: Bool
    // ) -> Bool {
    //     if (liquidity == 0) {
    //         return true
    //     }

    //     // let percentageScale = getPercentageScale()

    //     // let mut nextSqrtPrice = 0
    //     // if (byAmountIn == true) {
    //     //     let amountAfterFee = mul(amount, (one(percentageScale) - fee))
    //     //     // return getNextSqrtPriceFromInput()
    //     // } else {
    //     //     // return getNextSqrtPriceFromOutput()
    //     // }
    //     return true
    // }
    // pub fn calculate_max_liquidity_per_tick() {}
    // pub fn check_ticks() {}
    // pub fn check_tick() {}
    // pub fn calculate_min_amount_out() {}
}