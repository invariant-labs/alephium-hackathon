Contract CLAMM() extends Decimal(){ 
    // pub fn compute_swap_step() {}
    pub fn getDeltaX(
        sqrtPriceA: U256,
        sqrtPriceB: U256,
        liquidity: U256,
        roundingUp: Bool
    ) -> U256 {
        let sqrtPriceScale = getSqrtPriceScale()
        let liquidityScale = getLiquidityScale()

        let mut deltaSqrtPrice = 0u
        if (sqrtPriceA > sqrtPriceB) {
            deltaSqrtPrice = sqrtPriceA - sqrtPriceB
        } else {
            deltaSqrtPrice = sqrtPriceB - sqrtPriceA
        }

        let nominator = mulToValue(deltaSqrtPrice, liquidity, liquidityScale)
        if (roundingUp == true) {
            return divValuesToTokenUp(
                    nominator,
                    mulToValue(sqrtPriceA, sqrtPriceB, sqrtPriceScale)
                )
        } else {
            return divValuesToToken(
                nominator,
                mulToValueUp(sqrtPriceA, sqrtPriceB, sqrtPriceScale)
            )
        }
    }
    pub fn getDeltaY(
        sqrtPriceA: U256,
        sqrtPriceB: U256,
        liquidity: U256,
        roundingUp: Bool
    ) -> U256 {
        let sqrtPriceScale = getSqrtPriceScale()
        let liquidityScale = getLiquidityScale()
        
        let mut deltaSqrtPrice = 0u
        if (sqrtPriceA > sqrtPriceB) {
            deltaSqrtPrice = sqrtPriceA - sqrtPriceB
        } else {
            deltaSqrtPrice = sqrtPriceB - sqrtPriceA
        }

        if (roundingUp == true) {
            return mulToValueUp(deltaSqrtPrice, liquidity, liquidityScale) + almostOne(sqrtPriceScale) / one(sqrtPriceScale)
        } else {
            return mulToValue(deltaSqrtPrice, liquidity, liquidityScale) / one(sqrtPriceScale)
        }
    }
    // pub fn get_next_sqrt_price_from_input() {}
    // pub fn get_next_sqrt_price_from_output() {}
    pub fn getNextSqrtPriceXUp(
        startingSqrtPrice: U256,
        liquidity: U256,
        x: U256,
        addX: Bool
    ) -> U256 {
        if (x == 0) {
            return startingSqrtPrice
        }

        let liquidityScale = getLiquidityScale()
        let sqrtPriceScale = getSqrtPriceScale()
        let tokenAmountScale = getTokenAmountScale()

        let deltaSqrtPrice = fromDecimalToValue(liquidity, liquidityScale, sqrtPriceScale)

        let mut denominator = 1
        if (addX == true) {
            denominator = deltaSqrtPrice + mulToValue(startingSqrtPrice, x, tokenAmountScale) 
        } else {
            denominator = deltaSqrtPrice - mulToValue(startingSqrtPrice, x, tokenAmountScale)
        }

        return divValuesToTokenUp(
            mulToValueUp(startingSqrtPrice, liquidity, liquidityScale),
            denominator
        )
    }
    // pub fn get_next_sqrt_price_y_down() {}
    // pub fn calculate_amount_delta() {}
    // pub fn is_enough_amount_to_change_price() {}
    // pub fn calculate_max_liquidity_per_tick() {}
    // pub fn check_ticks() {}
    // pub fn check_tick() {}
    // pub fn calculate_min_amount_out() {}
}