struct U512 {
    mut higher: U256,
    mut lower: U256
}

struct ResultU256 {
    mut value: U256,
    mut error: U256
}

struct ResultU512 {
    mut value: U512,
    mut error: U256
}

Contract Uints () {
    const MaxU256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935

    enum ArithmeticError {
        CastOverflow = 100001
        AddOverflow = 100002
        SubUnderflow = 100003
        MulOverflow = 100004
        DivNotPositiveDivisor = 100005
        DivNotPositiveDenominator = 100006
        MulNotPositiveDenominator = 100007
    }

    pub fn unwrapU256(result: ResultU256) -> U256 {
        assert!(result.error == 0, result.error)
        return result.value
    }

    pub fn unwrapU512(result: ResultU512) -> U512 {
        assert!(result.error == 0, result.error)
        return result.value
    }
    
    pub fn toU512(value: U256) -> U512 {
        return U512 {
            higher: 0,
            lower: value
        }
    }

    pub fn toU256(value: U512) -> ResultU256 {
        if(value.higher > 0) {
            return ResultU256 { value: MaxU256, error: ArithmeticError.CastOverflow }
        }

        return ResultU256 { value: value.lower, error: 0 }
    }

    pub fn bigAdd256(a: U256, b: U256) -> U512 {
        let (lower, overflow) = overflowingAdd(a, b)
        
        if(overflow == 1) {
            return U512 { higher: 1, lower: lower }
        }

        return U512 { higher: 0, lower: lower }
    }

    pub fn bigAdd(a: U512, b: U256) -> ResultU512 {
        let (lower, lowerOverflow) = overflowingAdd(a.lower, b)
        let (higher, higherOverflow) = overflowingAdd(a.higher, lowerOverflow)

        if(higherOverflow == 1) {
            return ResultU512 { value: U512 { higher: MaxU256, lower: MaxU256 }, error: ArithmeticError.AddOverflow }
        }

        return ResultU512 { value:  U512 { higher: higher, lower: lower }, error: 0 }
    }

    pub fn bigAdd512(a: U512, b: U512) -> ResultU512 {
        let (lower, lowerOverflow) = overflowingAdd(a.lower, b.lower)
        let (higherIntermediate, higherIntermediateOverflow) = overflowingAdd(a.higher, b.higher)
        let (higher, higherOverflow) = overflowingAdd(higherIntermediate, lowerOverflow)

        if(higherIntermediateOverflow == 1 || higherOverflow == 1) {
            return ResultU512 { value: U512 { higher: MaxU256, lower: MaxU256 }, error: ArithmeticError.AddOverflow }
        }

        return ResultU512 { value: U512 { higher: higher, lower: lower }, error: 0 }
    }

    pub fn bigSub512(a: U512, b: U512) -> ResultU512 {
        if (b.higher > a.higher) {
            return ResultU512 { value: U512 { higher: MaxU256, lower: MaxU256 }, error: ArithmeticError.SubUnderflow }
        }

        let mut higher = a.higher - b.higher
        let mut lower = 0

        if (b.lower > a.lower) {
            if (higher == 0) {
                return ResultU512 { value: U512 { higher: MaxU256, lower: MaxU256 }, error: ArithmeticError.SubUnderflow }
            }

            higher = higher - 1
            lower = MaxU256 - b.lower + a.lower + 1
        } else {
            lower = a.lower - b.lower
        }

        return ResultU512 { value: U512 { higher: higher, lower: lower }, error: 0 }
    }

    pub fn bigDivWrapper(a: U512, b: U256, bDenominator: U256, up: Bool) -> ResultU512 {
        if(b == 0) {
            return ResultU512 { value: U512 { higher: MaxU256, lower: MaxU256 }, error: ArithmeticError.DivNotPositiveDivisor }
        }

        if(bDenominator == 0) {
            return ResultU512 { value: U512 { higher: MaxU256, lower: MaxU256 }, error: ArithmeticError.DivNotPositiveDenominator }
        }

        if (b == 1) {
            return ResultU512 { value: a, error: 0 }
        }

        // Calculate new higher
        let newHigher = a.higher * bDenominator
        let higher = newHigher / b
        let higherRemainder = newHigher % b
        // calculate higher remainder
        let maxDiv = MaxU256 / b
        let deltaHigherRemainder = higherRemainder * maxDiv
        // Calculate lower
        let newLower = a.lower * bDenominator
        let lower = newLower / b
        let mut deltaLower = deltaHigherRemainder + lower

        if (up) {
            let lowerRemainder = newLower % b

            let higherDecimal = deltaHigherRemainder % b
            if (higherDecimal + lowerRemainder != 0) {
                deltaLower = deltaLower + 1
            }
        }

        return ResultU512 { value: U512 { higher: higher, lower: deltaLower }, error: 0 }
    }

    pub fn bigDiv(a: U512, b: U256, bDenominator: U256) -> ResultU512 {
        return bigDivWrapper(a, b, bDenominator, false)
    }

    pub fn bigDivUp(a: U512, b: U256, bDenominator: U256) -> ResultU512 {
        return bigDivWrapper(a, b, bDenominator, true)
    }

    pub fn bigMul256(a: U256, b: U256) -> U512 {
        let aLower = low128(a)
        let aHigher = high128(a)
        let bLower = low128(b)
        let bHigher = high128(b)

        let aLowerBLower = aLower * bLower
        let aHigherBHigher = aHigher * bHigher
        let aHigherBLower = aHigher * bLower
        let aLowerBHigher = aLower * bHigher

        let lowerLower = low128(aLowerBLower)
        let lowerHigher = high128(aLowerBLower) + low128(aLowerBHigher) + low128(aHigherBLower)
        let higherLower = low128(aHigherBHigher) + high128(aLowerBHigher) + high128(aHigherBLower)
        let higherHigher = high128(aHigherBHigher)
        let lower = lowerLower + (lowerHigher << 128)
        let higher = high128(lowerHigher) + higherLower + (higherHigher << 128)

        return U512 { higher: higher, lower: lower }
    }

    pub fn bigMul(a: U512, b: U256) -> ResultU512 {        
        let result = bigMul256(a.lower, b)
        let higher = toU256(bigMul256(a.higher, b))
        
        if(higher.error != 0) {
            return ResultU512 { value: U512 { higher: MaxU256, lower: MaxU256 }, error: ArithmeticError.MulOverflow }
        }

        return bigAdd512(result, U512 { higher: higher.value, lower: 0 })
    }

    pub fn bigMulDiv256(a: U256, b: U256, bDenominator: U256) -> ResultU512 {
        if(bDenominator == 0) {
            return ResultU512 { value: U512 { higher: MaxU256, lower: MaxU256 }, error: ArithmeticError.MulNotPositiveDenominator }
        }

        let mut result = bigMul256(a, b)
        result = unwrapU512(bigDiv(result, bDenominator, 1))

        return ResultU512 { value: result, error: 0 }
    }

    pub fn bigMulDivUp256(a: U256, b: U256, bDenominator: U256) -> ResultU512 {
        if(bDenominator == 0) {
            return ResultU512 { value: U512 { higher: MaxU256, lower: MaxU256 }, error: ArithmeticError.MulNotPositiveDenominator }
        }

        let mut result = bigMul256(a, b)

        result = unwrapU512(bigAdd512(result, toU512(bDenominator - 1)))
        result = unwrapU512(bigDiv(result, bDenominator, 1))

        return ResultU512 { value: result, error: 0 }
    }
    
    pub fn overflowingAdd(a: U256, b: U256) -> (U256, U256) {
        if (MaxU256 - a >= b) {
            return a + b, 0
        }

        if (a > b) {
            return a - (MaxU256 - b) - 1, 1
        } else {
            return b - (MaxU256 - a) - 1, 1
        }
    }

    pub fn wrappingAdd(a: U256, b: U256) -> U256 {
        if (MaxU256 - a >= b) {
            return a + b
        }

        if (a > b) {
            return a - (MaxU256 - b) - 1
        } else {
            return b - (MaxU256 - a) - 1
        }
    }

    pub fn low128(a: U256) -> U256 {
        return a & ((1 << 128) - 1)
    }
    
    pub fn high128(a: U256) -> U256 {
        return a >> 128
    }

    pub fn bigDivToTokenUp(nominator: U512, denominator: U256, sqrtPriceDenominator: U256) -> ResultU256 {
        let mut wrappedResult = bigMul(nominator, sqrtPriceDenominator)
        if (wrappedResult.error != 0) {
            return ResultU256 { value: u256Max!(), error: wrappedResult.error }
        }
        let mut result = unwrapU512(wrappedResult)

        wrappedResult = bigAdd(result, denominator - 1)
        if (wrappedResult.error != 0) {
            return ResultU256 { value: u256Max!(), error: wrappedResult.error }
        }
        result = unwrapU512(wrappedResult)

        wrappedResult = bigDiv(result, denominator, 1)
        if (wrappedResult.error != 0) {
            return ResultU256 { value: u256Max!(), error: wrappedResult.error }
        }
        result = unwrapU512(wrappedResult)

        wrappedResult = bigAdd(result, sqrtPriceDenominator - 1)
        if (wrappedResult.error != 0) {
            return ResultU256 { value: u256Max!(), error: wrappedResult.error }
        }
        result = unwrapU512(wrappedResult)

        wrappedResult = bigDiv(result, sqrtPriceDenominator, 1)
        if (wrappedResult.error != 0) {
            return ResultU256 { value: u256Max!(), error: wrappedResult.error }
        }
        result = unwrapU512(wrappedResult)

        return toU256(result)
    }

    pub fn bigDivToToken(nominator: U512, denominator: U256, sqrtPriceDenominator: U256) -> ResultU256 {
        let mut wrappedResult = bigMul(nominator, sqrtPriceDenominator)
        if (wrappedResult.error != 0) {
            return ResultU256 { value: u256Max!(), error: wrappedResult.error }
        }
        let mut result = unwrapU512(wrappedResult)

        wrappedResult = bigDiv(result, denominator, 1)
        if (wrappedResult.error != 0) {
            return ResultU256 { value: u256Max!(), error: wrappedResult.error }
        }
        result = unwrapU512(wrappedResult)

        wrappedResult = bigDiv(result, sqrtPriceDenominator, 1)
        if (wrappedResult.error != 0) {
            return ResultU256 { value: u256Max!(), error: wrappedResult.error }
        }
        result = unwrapU512(wrappedResult)

        return toU256(result)
    }

    pub fn bigRescale(fromValue: U256, fromScale: U256, expectedScale: U256) -> U512 {
        if (expectedScale > fromScale) {
            let multiplierScale = expectedScale - fromScale
            return bigMul256(fromValue, 10 ** multiplierScale)
        } else {
            let denominatorScale = fromScale - expectedScale
            // Most likely does not require an extenstion to U512
            return bigDiv(toU512(fromValue), 10 ** denominatorScale, 1).value
        }
    }

    pub fn isZero(a: U512) -> Bool {
        return a.higher == 0 && a.lower == 0
    }

    pub fn bigDiv512(dividend: U512, divisor: U512, divisorDenominator: U256) -> ResultU512 {
        let mut q = U512 { higher: 0, lower: 0 }
        let mut r = U512 { higher: 0, lower: 0 }
    
        if(isZero(divisor)) {
            return ResultU512 { value: U512 { higher: MaxU256, lower: MaxU256 }, error: ArithmeticError.DivNotPositiveDivisor }
        }

        if(divisorDenominator == 0) {
            return ResultU512 { value: U512 { higher: MaxU256, lower: MaxU256 }, error: ArithmeticError.DivNotPositiveDenominator }
        }

        if (dividend.higher == 0) {
            let mulResult = bigMul256(dividend.lower, divisorDenominator)
            
            if (mulResult.higher == 0) {
                return ResultU512 { value: U512 { higher: 0, lower: mulResult.lower / divisor.lower }, error: 0 }
            }
            let divResult = bigDiv512(mulResult, divisor, 1)
            return divResult
        }
    
        let mut uHigh = dividend.higher * divisorDenominator
        let mut uLow = dividend.lower * divisorDenominator
        let v = divisor
    
        for (let mut j = 511; j > 0; j = j - 1) {
            r.lower = r.lower << 1 | (r.higher >> 255)
            r.higher = r.higher << 1
    
            if (((uHigh >> 255) & 1) != 0) {
                r.lower = r.lower | 1
            }

            uHigh = uHigh << 1
    
            if ((uLow >> 255) != 0) {
                uHigh = uHigh | 1
            }
            uLow = uLow << 1
    
            if (r.higher > v.higher || (r.higher == v.higher && r.lower >= v.lower)) {
                let mut borrow = 1

                if (r.lower >= v.lower) {
                    borrow = 0
                }
            
                r.lower = r.lower - (v.lower + borrow)
                r.higher = r.higher - (v.higher + borrow)
                
                if (j >= 256) {
                    q.higher = q.higher | (1 << (j - 256))
                } else {
                    q.lower = q.lower | (1 << j)
                }
            }
        }

        return ResultU512 { value: q, error: 0 }
    }

    pub fn bigDivUp512(dividend: U512, divisor: U512, divisorDenominator: U256) -> ResultU512 {
        let mut result = unwrapU512(bigMul(dividend, divisorDenominator))
        result = unwrapU512(bigAdd512(result, divisor))
        result.lower = result.lower - 1
        return bigDiv512(result, divisor, 1)
    }
}                           

