struct U512 {
    mut higher: U256,
    mut lower: U256
}

Contract Uints () {
    const MaxU256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935

    enum ArithmeticError {
        CastOverflow = 100001
        AddOverflow = 100002
        DivNotPositiveDivisor = 100003
        DivNotPositiveDenominator = 100004
        MulNotPositiveDenominator = 100005
        DecrementUnderflow = 100006
    }
    
    pub fn toU512(value: U256) -> U512 {
        return U512 {
            higher: 0,
            lower: value
        }
    }

    pub fn toU256(value: U512) -> U256 {
        assert!(value.higher == 0, ArithmeticError.CastOverflow)
        return value.lower
    }

    pub fn bigAdd256(a: U256, b: U256) -> U512 {
        let (lower, overflow) = overflowingAdd(a, b)
        
        if(overflow == 1) {
            return U512 { higher: 1, lower: lower }
        }

        return U512 { higher: 0, lower: lower }
    }

    pub fn bigAdd(a: U512, b: U256) -> U512 {
        let (lower, lowerOverflow) = overflowingAdd(a.lower, b)
        let (higher, higherOverflow) = overflowingAdd(a.higher, lowerOverflow)

        assert!(higherOverflow == 0, ArithmeticError.AddOverflow)

        return U512 { higher: higher, lower: lower }
    }

    pub fn bigAdd512(a: U512, b: U512) -> U512 {
        let (lower, lowerOverflow) = overflowingAdd(a.lower, b.lower)
        let (higherIntermediate, higherIntermediateOverflow) = overflowingAdd(a.higher, b.higher)
        let (higher, higherOverflow) = overflowingAdd(higherIntermediate, lowerOverflow)

        assert!(higherIntermediateOverflow != 1 && higherOverflow != 1, ArithmeticError.AddOverflow)

        return U512 { higher: higher, lower: lower }
    }

    pub fn bigDivWrapper(a: U512, b: U256, bDenominator: U256) -> U512 {
        assert!(b != 0, ArithmeticError.DivNotPositiveDivisor)
        assert!(bDenominator != 0, ArithmeticError.DivNotPositiveDenominator)

        let mut q = U512 { higher: 0, lower: 0 }
        let mut r = 0

        let extA = bigMul(a, bDenominator)

        if (extA.higher == 0) {
            return U512 { higher: 0, lower: extA.lower / b }
        }

        if (b == MaxU256) {
            return U512 { higher: 0, lower: extA.higher }
        }

        if (b == 1) {
            return extA
        }

        let mut uHigh = extA.higher
        let mut uLow = extA.lower
        let v = b

        let mut j = 512
        while (j > 0) {
            j = j - 1
            r = r << 1

            if (((uHigh >> 255) & 1) != 0) {
                r = r | 1
            }
            uHigh = uHigh << 1

            if ((uLow >> 255) != 0) {
                uHigh = uHigh | 1
            }
            uLow = uLow << 1
            if (r >= v) {
                r = r - v
                if (j >= 256) {
                    q.higher = q.higher | (1 << (j - 256))
                } else {
                    q.lower = q.lower | (1 << j)
                }
            }
        }

        return q
    }

    pub fn bigDiv(a: U512, b: U256, bDenominator: U256) -> U512 {
        return bigDivWrapper(a, b, bDenominator)
    }

    pub fn decrement(a: U512) -> U512 {
        if(a.lower == 0) {
            assert!(a.higher > 0, ArithmeticError.DecrementUnderflow)
            return U512 { higher: a.higher - 1, lower: MaxU256 }
        }

        return U512 { higher: a.higher, lower: a.lower - 1 }
    }

    pub fn bigDivUp(a: U512, b: U256, bDenominator: U256) -> U512 {
        assert!(b != 0, ArithmeticError.DivNotPositiveDivisor)
        assert!(bDenominator != 0, ArithmeticError.DivNotPositiveDenominator)

        let mut result = bigMul(a, bDenominator)
        result = bigAdd(result, b)
        result = decrement(result)
        return bigDivWrapper(result, b, 1)
    }

    pub fn bigMul256(a: U256, b: U256) -> U512 {
        let aLower = low128(a)
        let aHigher = high128(a)
        let bLower = low128(b)
        let bHigher = high128(b)

        let aLowerBLower = aLower * bLower
        let aHigherBHigher = aHigher * bHigher
        let aHigherBLower = aHigher * bLower
        let aLowerBHigher = aLower * bHigher

        let lowerLower = low128(aLowerBLower)
        let lowerHigher = high128(aLowerBLower) + low128(aLowerBHigher) + low128(aHigherBLower)
        let higherLower = low128(aHigherBHigher) + high128(aLowerBHigher) + high128(aHigherBLower)
        let higherHigher = high128(aHigherBHigher)
        let lower = lowerLower + (lowerHigher << 128)
        let higher = high128(lowerHigher) + higherLower + (higherHigher << 128)

        return U512 { higher: higher, lower: lower }
    }

    pub fn bigMulUpU256(a: U256, b: U256, bDenominator: U256) -> U512 {
        let mut result = bigMul256(a, b)
        result = bigAdd(result, bDenominator - 1)
        return bigDiv(result, bDenominator, 1)
    }

    pub fn bigMul(a: U512, b: U256) -> U512 {        
        let result = bigMul256(a.lower, b)
        let higher = toU256(bigMul256(a.higher, b))

        return bigAdd512(result, U512 { higher: higher, lower: 0 })
    }

    pub fn bigMulDiv256(a: U256, b: U256, bDenominator: U256) -> U512 {
        assert!(bDenominator != 0, ArithmeticError.MulNotPositiveDenominator)

        let mut result = bigMul256(a, b)
        result = bigDiv(result, bDenominator, 1)

        return result
    }

    pub fn bigMulDivUp256(a: U256, b: U256, bDenominator: U256) -> U512 {
        assert!(bDenominator != 0, ArithmeticError.MulNotPositiveDenominator)
        let mut result = bigMul256(a, b)

        result = bigAdd512(result, toU512(bDenominator - 1))
        result = bigDiv(result, bDenominator, 1)

        return result
    }
    
    pub fn overflowingAdd(a: U256, b: U256) -> (U256, U256) {
        if (MaxU256 - a >= b) {
            return a + b, 0
        }

        if (a > b) {
            return a - (MaxU256 - b) - 1, 1
        } else {
            return b - (MaxU256 - a) - 1, 1
        }
    }

    pub fn wrappingAdd(a: U256, b: U256) -> U256 {
        if (MaxU256 - a >= b) {
            return a + b
        }

        if (a > b) {
            return a - (MaxU256 - b) - 1
        } else {
            return b - (MaxU256 - a) - 1
        }
    }

    pub fn low128(a: U256) -> U256 {
        return a & ((1 << 128) - 1)
    }
    
    pub fn high128(a: U256) -> U256 {
        return a >> 128
    }

    pub fn bigDivToTokenUp(nominator: U512, denominator: U256, sqrtPriceDenominator: U256) -> U256 {
        let mut result = bigMul(nominator, sqrtPriceDenominator)
        result = bigAdd(result, denominator - 1)
        result = bigDiv(result, denominator, 1)
        result = bigAdd(result, sqrtPriceDenominator - 1)
        result = bigDiv(result, sqrtPriceDenominator, 1)

        return toU256(result)
    }

    pub fn bigDivToToken(nominator: U512, denominator: U256, sqrtPriceDenominator: U256) -> U256 {
        let mut result = bigMul(nominator, sqrtPriceDenominator)
        result = bigDiv(result, denominator, 1)
        result = bigDiv(result, sqrtPriceDenominator, 1)

        return toU256(result)
    }
}                           

