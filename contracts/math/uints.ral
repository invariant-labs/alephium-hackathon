struct U512 {
    mut higher: U256,
    mut lower: U256
}

Contract Uints () {
    const MaxU256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935

    enum ArithmeticErrors {
        CastOverflow = 100001
        NotPositiveDivisor = 100002
    }
    
    pub fn toU512(v: U256) -> U512 {
        return U512 {
            higher: 0,
            lower: v
        }
    }

    pub fn toU256(v: U512) -> U256 {
        assert!(v.higher == 0, ArithmeticErrors.CastOverflow)
        return v.lower  
    }

    pub fn bigAdd(a: U256, b: U256) -> U512 {
        if (MaxU256 - a < b) {
            return U512 {
                higher: 1,
                lower: (b - (MaxU256 - a)) - 1
            }
        } else {
            return U512 {
                higher: 0,
                lower: a + b
            }
        }
    }

        pub fn bigDiv(a: U512, divisor: U256, denominator: U256) -> U512 {
            assert!(divisor > 0, ArithmeticErrors.NotPositiveDivisor)

            if (divisor == 1) {
                return a
            }

            // Calculate new higher
            let newh = a.higher * denominator 
            let h = newh / divisor
            let hr = newh % divisor
            // calculate higher remainder
            let maxdiv = MaxU256 / divisor
            let deltahr = hr * maxdiv
            // Calculate lower
            let l = a.lower * denominator / divisor
            let deltal = deltahr + l

            return U512 {
                higher: h,
                lower: deltal
            }
        }

        pub fn bigDivUp(a: U512, divisor: U256, denominator: U256) -> U512 {
            assert!(divisor > 0, 0x02)
            if (divisor == 1) {
                return a
            }

            // Calculate new higher
            let newh = a.higher * denominator
            let h = newh / divisor
            let hr = newh % divisor
            // calculate higher remainder
            let maxdiv = MaxU256 / divisor
            let deltahr = hr * maxdiv
            let hdecimal = deltahr % divisor
            // Calculate lower
            let newl = a.lower * denominator
            let l = newl / divisor
            let lr = newl % divisor
            let mut deltaL = deltahr + l

            if (hdecimal + lr != 0) {
                deltaL = deltaL + 1
            }

            return U512 {
                higher: h,
                lower: deltaL
            }
        }

    pub fn bigAdd512(a: U512, b: U512) -> U512 {
        let (r0, overflow) = overflowingAdd(a.lower, b.lower)
        let r1 = wrappingAdd(wrappingAdd(a.higher, b.higher), overflow)
        return U512 { higher: r1, lower: r0 }
    }

    pub fn bigMul(a: U256, b: U256, denominator: U256) -> U512 {
        let aLower = low128(a)
        let aHigher = high128(a)
        let bLower = low128(b)
        let bHigher = high128(b)

        let rLowerLower = aLower * bLower
        let rHigherHigher = aHigher * bHigher
        let rHigherLower = aHigher * bLower
        let rLowerHigher = aLower * bHigher

        let mut result = bigAdd512(U512 { higher: rHigherHigher, lower: rLowerLower }, U512 { higher: high128(rHigherLower), lower: low128(rHigherLower) << 128 })
        result = bigAdd512(result, U512 { higher: high128(rLowerHigher), lower: low128(rLowerHigher) << 128 })

        result = bigDiv(result, denominator, 1)

        return result
    }

    pub fn bigMulUp(a: U256, b: U256, denominator: U256) -> U512 {
        let a0 = low128(a)
        let a1 = high128(a)
        let b0 = low128(b)
        let b1 = high128(b)

        let r0 = a0 * b0
        let r1 = a1 * b1
        let r2 = a1 * b0
        let r3 = a0 * b1

        let mut result = bigAdd512(U512 { higher: r1, lower: r0 }, U512 { higher: high128(r2), lower: low128(r2) << 128 })
        result = bigAdd512(result, U512 { higher: high128(r3), lower: low128(r3) << 128 })

        result = bigAdd512(result, U512 { higher: 0, lower: 10 ** denominator - 1 })
        result = bigDiv(result, denominator, 1)

        return result
    }
    
    pub fn overflowingAdd(a: U256, b: U256) -> (U256, U256) {
        if (u256Max!() - a >= b) {
            return a + b, 0
        } else {
            return b + (u256Max!() - a) - 1, 1
        }
    }

    pub fn wrappingAdd(a: U256, b: U256) -> U256 {
        let u256Max = u256Max!()

        if (u256Max - a >= b) {
            return a + b
        } else {
            return b + (u256Max - a) - 1
        }
    }

    pub fn low128(a: U256) -> U256 {
        return a << 128 >> 128
    }
    
    pub fn high128(a: U256) -> U256 {
        return a >> 128
    }
}                           

