struct U512 {
    mut higher: U256,
    mut lower: U256
}

Abstract Contract U512Impl () {
    const MaxU256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935

    enum ArithmeticErrors {
        CastOverflow = 100001
    }
    
    pub fn toU512(v: U256) -> U512 {
        return U512 {
            higher: 0,
            lower: v
        }
    }

    pub fn toU256(v: U512) -> U256 {
        assert!(v.higher == 0, ArithmeticErrors.CastOverflow)
        return v.lower  
    }

    pub fn bigAdd(a: U256, b: U256) -> U512 {
        let u256Max = u256Max!()
        if (u256Max - a < b) {
            return U512 {
                higher: 1,
                lower: (b - (u256Max - a)) - 1
            }
        } else {
            return U512 {
                higher: 0,
                lower: a + b
            }
        }
    }

        pub fn bigDiv(a: U512, divisor: U256, denominator: U256) -> U512 {
            assert!(divisor > 0, 0x02)
            if (divisor == 1) {
                return a
            }


            // Calculate new higher
            let newh = a.higher * denominator 
            let h = newh / divisor
            let hr = newh % divisor
            // calculate higher remainder
            let maxdiv = MaxU256 / divisor
            let deltahr = hr * maxdiv
            // Calculate lower
            let l = (a.lower * denominator) / divisor
            let deltaL = deltahr + l

            return U512 {
                higher: h,
                lower: deltaL
            }
        }

        pub fn bigDivUp(a: U512, divisor: U256, denominator: U256) -> U512 {
            assert!(divisor > 0, 0x02)
            if (divisor == 1) {
                return a
            }


            // Calculate new higher
            let newh = a.higher * denominator
            let h = newh / divisor
            let hr = newh % divisor
            // calculate higher remainder
            let maxdiv = MaxU256 / divisor
            let deltahr = hr * maxdiv
            let hdecimal = deltahr % divisor
            // Calculate lower
            let newl = a.lower * denominator
            let l = newl / divisor
            let lr = newl % divisor
            let mut deltaL = deltahr + l

            if (hdecimal + lr != 0) {
                deltaL = deltaL + 1
            }

            return U512 {
                higher: h,
                lower: deltaL
            }
        }
}                           

