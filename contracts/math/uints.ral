struct U512 {
    mut higher: U256,
    mut lower: U256
}

Abstract Contract U512Impl () {
    const MaxU256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935

    enum ArithmeticErrors {
        CastOverflow = 100001
        DivByZero = 100002
    }
    
    pub fn toU512(v: U256) -> U512 {
        return U512 {
            higher: 0,
            lower: v
        }
    }

    pub fn toU256(v: U512) -> U256 {
        assert!(v.higher == 0, ArithmeticErrors.CastOverflow)
        return v.lower  
    }

    pub fn bigAdd(a: U256, b: U256) -> U512 {
        let sub = MaxU256 - a
        if (sub < b) {
            return U512 {
                higher: 1,
                lower: (b - sub) - 1
            }
        } else {
            return U512 {
                higher: 0,
                lower: a + b
            }
        }
    }

    pub fn bigDiv(a: U512, divisor: U256, denominator: U256) -> U512 {
        assert!(divisor != 0, ArithmeticErrors.DivByZero)

        if (divisor == 1) {
            return a
        }

        if (a.higher == 0) {
            return U512 {
                higher: 0,
                lower: a.lower * denominator / divisor
            }
        }

        // Calculate new higher
        let newh = a.higher * denominator 
        let h = newh / divisor
        let hr = newh % divisor
        // calculate higher remainder
        let deltahr = hr * (MaxU256 / divisor)
        // Calculate lower
        let l = a.lower * denominator / divisor

        return U512 {
            higher: h,
            lower: deltahr + l
        }
    }

    pub fn bigDivUp(a: U512, divisor: U256, denominator: U256) -> U512 {
        assert!(divisor != 0, ArithmeticErrors.DivByZero)

        if (divisor == 1) {
            return a
        }

        // Calculate lower
        let newl = a.lower * denominator
        let l = newl / divisor
        let lr = newl % divisor

        if (a.higher == 0) {
            if (lr != 0) {
                return U512 {
                    higher: 0,
                    lower: l + 1
                }
            } else {
                return U512 {
                    higher: 0,
                    lower: l
                }
            }
        }

        // Calculate new higher
        let newh = a.higher * denominator
        let h = newh / divisor
        let hr = newh % divisor
        // calculate higher remainder
        let deltahr = hr * (MaxU256 / divisor)
        let hdecimal = deltahr % divisor

        if (hdecimal != 0 || lr != 0) {               
            return U512 {
                higher: h,
                lower: deltahr + l + 1
            }
        }

        return U512 {
            higher: h,
            lower: deltahr + l
        }
    }
}                           

