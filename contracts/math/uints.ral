struct Result {
    mut value: U512,
    mut error: Bool
}

struct U512 {
    mut higher: U256,
    mut lower: U256
}

Contract Uints () {
    const MaxU256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935

    enum ArithmeticErrors {
        CastOverflow = 100001
        NotPositiveDivisor = 100002
    }
    
    pub fn toU512(v: U256) -> U512 {
        return U512 {
            higher: 0,
            lower: v
        }
    }

    pub fn toU256(v: U512) -> U256 {
        assert!(v.higher == 0, ArithmeticErrors.CastOverflow)
        return v.lower  
    }

    pub fn bigAdd256(a: U256, b: U256) -> U512 {
        if (MaxU256 - a < b) {
            return U512 {
                higher: 1,
                lower: (b - (MaxU256 - a)) - 1
            }
        } else {
            return U512 {
                higher: 0,
                lower: a + b
            }
        }
    }

    pub fn bigAdd(a: U512, b: U256) -> U512 {
        let (lower, overflow) = overflowingAdd(a.lower, b)
        let higher = wrappingAdd(a.higher, overflow)
        return U512 { lower: lower, higher: higher }
    }

    pub fn bigAdd512(a: U512, b: U512) -> U512 {
        let (aLowerBLower, overflow) = overflowingAdd(a.lower, b.lower)
        let aHigherBHigherOverflow = wrappingAdd(wrappingAdd(a.higher, b.higher), overflow)
        return U512 { lower: aLowerBLower, higher: aHigherBHigherOverflow }
    }

    pub fn bigDivWrapper(a: U512, b: U256, bDenominator: U256, up: Bool) -> U512 {
        assert!(b > 0, ArithmeticErrors.NotPositiveDivisor)

        if (b == 1) {
            return a
        }

        // Calculate new higher
        let newHigher = a.higher * bDenominator
        let higher = newHigher / b
        let higherRemainder = newHigher % b
        // calculate higher remainder
        let maxDiv = MaxU256 / b
        let deltaHigherRemainder = higherRemainder * maxDiv
        // Calculate lower
        let newLower = a.lower * bDenominator
        let lower = newLower / b
        let mut deltaLower = deltaHigherRemainder + lower

        if (up) {
            let lowerRemainder = newLower % b

            let higherDecimal = deltaHigherRemainder % b
            if (higherDecimal + lowerRemainder != 0) {
                deltaLower = deltaLower + 1
            }
        }

        return U512 {
            higher: higher,
            lower: deltaLower
        }
    }

    pub fn bigDiv512(a: U512, b: U256, bDenominator: U256) -> U512 {
        return bigDivWrapper(a, b, bDenominator, false)
    }

    pub fn bigDivUp512(a: U512, b: U256, bDenominator: U256) -> U512 {
        return bigDivWrapper(a, b, bDenominator, true)
    }

    pub fn bigMul512(a: U512, b: U256) -> U512 {        
        let result = bigMul256(a.lower, b)
        return bigAdd512(result, U512 { higher: a.higher * b, lower: 0 })
    }

    pub fn bigMul256(a: U256, b: U256) -> U512 {
        let aLower = low128(a)
        let aHigher = high128(a)
        let bLower = low128(b)
        let bHigher = high128(b)

        let aLowerBLower = aLower * bLower
        let aHigherBHigher = aHigher * bHigher
        let aHigherBLower = aHigher * bLower
        let aLowerBHigher = aLower * bHigher

        let lowerLower = low128(aLowerBLower)
        let lowerHigher = high128(aLowerBLower) + low128(aLowerBHigher) + low128(aHigherBLower)
        let higherLower = low128(aHigherBHigher) + high128(aLowerBHigher) + high128(aHigherBLower)
        let higherHigher = high128(aHigherBHigher)
        let lower = lowerLower + (lowerHigher << 128)
        let higher = high128(lowerHigher) + higherLower + (higherHigher << 128)

        return U512 { higher: higher, lower: lower }
    }

    pub fn bigMulDiv256(a: U256, b: U256, bDenominator: U256) -> U512 {
        let mut result = bigMul256(a, b)

        result = bigDiv512(result, bDenominator, 1)

        return result
    }

    pub fn bigMulDivUp256(a: U256, b: U256, bDenominator: U256) -> U512 {
        let mut result = bigMul256(a, b)

        result = bigAdd512(result, U512 { higher: 0, lower: bDenominator - 1 })
        result = bigDiv512(result, bDenominator, 1)

        return result
    }
    
    pub fn overflowingAdd(a: U256, b: U256) -> (U256, U256) {
        if (MaxU256 - a >= b) {
            return a + b, 0
        } else {
            return b + (MaxU256 - a) - 1, 1
        }
    }

    pub fn wrappingAdd(a: U256, b: U256) -> U256 {
        if (MaxU256 - a >= b) {
            return a + b
        } else {
            return b + (MaxU256 - a) - 1
        }
    }

    pub fn low128(a: U256) -> U256 {
        return a & ((1 << 128) - 1)
    }
    
    pub fn high128(a: U256) -> U256 {
        return a >> 128
    }

    pub fn bigDivToTokenUp(nominator: U512, denominator: U256, sqrtPriceDenominator: U256) -> U256 {
        let mut result = bigMul512(nominator, sqrtPriceDenominator)
        result = bigAdd(result, denominator - 1)
        result = bigDiv512(result, denominator, 1)
        result = bigAdd(result, sqrtPriceDenominator - 1)
        result = bigDiv512(result, sqrtPriceDenominator, 1)
        return toU256(result)
    }

    pub fn bigDivToToken(nominator: U512, denominator: U256, sqrtPriceDenominator: U256) -> U256 {
        let mut result = bigMul512(nominator, sqrtPriceDenominator)
        result = bigDiv512(result, denominator, 1)
        result = bigDiv512(result, sqrtPriceDenominator, 1)
        return toU256(result)
    }
}                           

