struct SingleTokenLiquidity {
    mut l: Liquidity,
    mut amount: TokenAmount
}

struct LiquidityResult {
    x: TokenAmount,
    y: TokenAmount,
    l: Liquidity
}

Contract Utils() extends Uints(), Decimal(), Log(), PoolKeyHelper(), FeeTierHelper(), Tickmap() {
    // Placeholder to allow exporting tickmap methods
    // Key: poolKey ++ subcontract index
    mapping[ByteVec, TickmapBatch] bitmap

    enum UtilsError {
        InvalidTickIndex = 900
        UpperLTCurrentSqrtPrice = 901
        CurrentLTLowerSqrtPrice = 902
    }

    enum InvariantError {
        // NotAdmin = 0
        // InsufficientLiquidity = 1
        InvalidTickSpacing = 2
        InvalidFee = 3
        // FeeTierNotFound = 4
        TokensAreSame = 5
        // PoolKeyAlreadyExist = 6
        // TickAndSqrtPriceMismatch = 7
        // NotFeeReceiver = 8
        // InvalidTickLiquidity = 9
        // ZeroLiquidity = 10
        // PriceLimitReached = 11
        // InvalidProtocolFee = 12
        // NotOwner = 13
        // ZeroAmount = 14
        // WrongPriceLimit = 15
        // NoGainSwap = 16
        // PositionDoesNotExist = 17
        // FeeTierAlreadyExist = 18
        // PoolNotFound = 19
        // PoolAlreadyExist = 20
        // TickAlreadyExist = 21
        InvalidTickIndex = 22
        TickAndTickSpacingMismatch = 23
        TickLimitReached = 24
        ChunkNotFound = 25
        InvalidTickmapBit = 26
        // PositionNotFound = 27
    }

    pub fn getLiquidityByX(x: TokenAmount, lowerTick: I256, upperTick: I256, currentSqrtPrice: SqrtPrice, roundingUp: Bool) -> SingleTokenLiquidity {
        assert!(lowerTick >= GlobalMinTick && upperTick <= GlobalMaxTick, UtilsError.InvalidTickIndex)
        let lowerSqrtPrice = calculateSqrtPrice(lowerTick)
        let upperSqrtPrice = calculateSqrtPrice(upperTick)

        return getLiquidityByXSqrtPrice(x, lowerSqrtPrice, upperSqrtPrice, currentSqrtPrice, roundingUp)
    }

    pub fn getLiquidityByXSqrtPrice(x: TokenAmount, lowerSqrtPrice: SqrtPrice, upperSqrtPrice: SqrtPrice, currentSqrtPrice: SqrtPrice, roundingUp: Bool) -> SingleTokenLiquidity {
        assert!(upperSqrtPrice.v >= currentSqrtPrice.v, UtilsError.UpperLTCurrentSqrtPrice)

        let mut nominator = U512 { higher: 0, lower: 0}
        let mut denominator = 0
        let mut liquidity = Liquidity{v: 0}
        if (currentSqrtPrice.v < lowerSqrtPrice.v) {
            nominator = bigMulDiv256(lowerSqrtPrice.v, upperSqrtPrice.v, one(SqrtPriceScale))
            denominator = upperSqrtPrice.v - lowerSqrtPrice.v
            liquidity.v = toU256(bigDiv(bigMul(bigMul(nominator, x.v), one(LiquidityScale)), denominator, 1))
            return SingleTokenLiquidity { l: liquidity, amount: TokenAmount{v: 0} }
        }

        nominator = bigMulDiv256(currentSqrtPrice.v, upperSqrtPrice.v, one(SqrtPriceScale))
        denominator = upperSqrtPrice.v - currentSqrtPrice.v
        liquidity.v = toU256(bigDiv(bigMul(bigMul(nominator, x.v), one(LiquidityScale)), denominator, 1))
        let sqrtPriceDiff = SqrtPrice{v: currentSqrtPrice.v - lowerSqrtPrice.v}
        let y = calculateY(sqrtPriceDiff, liquidity, roundingUp)
        return SingleTokenLiquidity { l: liquidity, amount: y }
    }

    pub fn calculateY(sqrtPriceDiff: SqrtPrice, liquidity: Liquidity, roundingUp: Bool) -> TokenAmount {
        let shiftedLiquidity = liquidity.v / one(LiquidityScale)
        if (roundingUp) {
            return TokenAmount{v: (sqrtPriceDiff.v * shiftedLiquidity + almostOne(SqrtPriceScale)) / one(SqrtPriceScale)}
        } else {
            return TokenAmount{v: sqrtPriceDiff.v * shiftedLiquidity / one(SqrtPriceScale)}
        }
    }

    pub fn getLiquidityByY(y: TokenAmount, lowerTick: I256, upperTick: I256, currentSqrtPrice: SqrtPrice, roundingUp: Bool) -> SingleTokenLiquidity {
        assert!(lowerTick >= GlobalMinTick && upperTick <= GlobalMaxTick, UtilsError.InvalidTickIndex)
        let lowerSqrtPrice = calculateSqrtPrice(lowerTick)
        let upperSqrtPrice = calculateSqrtPrice(upperTick)

        return getLiquidityByYSqrtPrice(y, lowerSqrtPrice, upperSqrtPrice, currentSqrtPrice, roundingUp)
    }

    pub fn getLiquidityByYSqrtPrice(y: TokenAmount, lowerSqrtPrice: SqrtPrice, upperSqrtPrice: SqrtPrice, currentSqrtPrice: SqrtPrice, roundingUp: Bool) -> SingleTokenLiquidity {
        assert!(currentSqrtPrice.v >= lowerSqrtPrice.v, UtilsError.CurrentLTLowerSqrtPrice)

        let mut sqrtPriceDiff = 0
        let mut liquidity = 0

        if (upperSqrtPrice.v <= currentSqrtPrice.v) {
            sqrtPriceDiff = upperSqrtPrice.v - lowerSqrtPrice.v
            liquidity = toU256(bigDiv(bigMul(bigMul256(y.v, one(SqrtPriceScale)), one(LiquidityScale)), sqrtPriceDiff, 1))
            return SingleTokenLiquidity { l: Liquidity{v: liquidity}, amount: TokenAmount{v: 0} }
        }

        sqrtPriceDiff = currentSqrtPrice.v - lowerSqrtPrice.v
        liquidity = toU256(bigDiv(bigMul(bigMul256(y.v, one(SqrtPriceScale)), one(LiquidityScale)), sqrtPriceDiff, 1))
        let denominator = (currentSqrtPrice.v * upperSqrtPrice.v )/ one(SqrtPriceScale)
        let nominator = upperSqrtPrice.v - currentSqrtPrice.v
        let x = calculateX(nominator, denominator, liquidity, roundingUp)
        return SingleTokenLiquidity { l: Liquidity{v: liquidity}, amount: TokenAmount{v: x} }
    }

    pub fn calculateX(nominator: U256, denominator: U256, liquidity: U256, roundingUp: Bool) -> U256 {
        let common = bigMulDiv256(liquidity, nominator, denominator)
        if (roundingUp) {
            return toU256(bigDiv(bigAdd(common, almostOne(LiquidityScale)), one(LiquidityScale), 1))
        } else {
            return toU256(bigDiv(common, one(LiquidityScale), 1))
        }
    }

    pub fn getLiquidity(x: TokenAmount, y: TokenAmount, lowerTick: I256, upperTick: I256, currentSqrtPrice: SqrtPrice, roundingUp: Bool) -> LiquidityResult {
        assert!(lowerTick >= GlobalMinTick && upperTick <= GlobalMaxTick, UtilsError.InvalidTickIndex)
        let lowerSqrtPrice = calculateSqrtPrice(lowerTick)
        let upperSqrtPrice = calculateSqrtPrice(upperTick)

        let mut resultByX = SingleTokenLiquidity { l: Liquidity{v: 0}, amount: TokenAmount{v: 0}}
        let mut resultByY = SingleTokenLiquidity { l: Liquidity{v: 0}, amount: TokenAmount{v: 0}}

        if (upperSqrtPrice.v < currentSqrtPrice.v) {
            resultByY = getLiquidityByYSqrtPrice(y, lowerSqrtPrice, upperSqrtPrice, currentSqrtPrice, roundingUp)
            return LiquidityResult { x:  resultByY.amount, y: y, l: resultByY.l } 
        } else if (currentSqrtPrice.v < lowerSqrtPrice.v) {
            resultByX = getLiquidityByXSqrtPrice(x, lowerSqrtPrice, upperSqrtPrice, currentSqrtPrice, roundingUp)
            return LiquidityResult { x: x, y: resultByX.amount, l: resultByX.l }
        } else {
            // do nothing
        }

        resultByY = getLiquidityByYSqrtPrice(y, lowerSqrtPrice, upperSqrtPrice, currentSqrtPrice, roundingUp)
        resultByX = getLiquidityByXSqrtPrice(x, lowerSqrtPrice, upperSqrtPrice, currentSqrtPrice, roundingUp)

        if(resultByY.l.v < resultByX.l.v) {
            return LiquidityResult { x: resultByY.amount, y: resultByX.amount, l: resultByY.l }
        } else {
            return LiquidityResult { x: resultByY.amount, y: resultByX.amount, l: resultByX.l }
        }
    }

    pub fn isTokenX(candidate: Address, compareTo: Address) -> Bool {
        let candidateBytes = toByteVec!(candidate)
        let compareToBytes = toByteVec!(compareTo)

        assert!(candidateBytes != compareToBytes, InvariantError.TokensAreSame)

        for (let mut i = 0; i <= size!(candidateBytes); i = i + 1) {
            if (u256From1Byte!(byteVecSlice!(candidateBytes, i, i + 1)) < u256From1Byte!(byteVecSlice!(compareToBytes, i, i + 1))) {
                return true
            } else {
                return false
            }
        }

        return true
    }

    pub fn calculateFee(
        tickLowerIndex: I256,
        tickLowerFeeGrowthOutsideX: FeeGrowth,
        tickLowerFeeGrowthOutsideY: FeeGrowth,
        tickUpperIndex: I256,
        tickUpperFeeGrowthOutsideX: FeeGrowth,
        tickUpperFeeGrowthOutsideY: FeeGrowth,
        tickCurrent: I256,
        globalFeeGrowthX: FeeGrowth,
        globalFeeGrowthY: FeeGrowth,
        positionFeeGrowthInsideX: FeeGrowth,
        positionFeeGrowthInsideY: FeeGrowth,
        positionLiquidity: Liquidity
    ) -> (U256, U256) {
        let (feeGrowthInsideX, feeGrowthInsideY) = calculateFeeGrowthInside(
            tickLowerIndex,
            tickLowerFeeGrowthOutsideX,
            tickLowerFeeGrowthOutsideY,
            tickUpperIndex,
            tickUpperFeeGrowthOutsideX,
            tickUpperFeeGrowthOutsideY,
            tickCurrent,
            globalFeeGrowthX,
            globalFeeGrowthY
        )

        let tokensOwedX = toFee(FeeGrowth{v: wrappingSub(feeGrowthInsideX.v, positionFeeGrowthInsideX.v)}, positionLiquidity)
        let tokensOwedY = toFee(FeeGrowth{v: wrappingSub(feeGrowthInsideY.v, positionFeeGrowthInsideY.v)}, positionLiquidity)

        return tokensOwedX, tokensOwedY
    }

    pub fn toFee(feeGrowth: FeeGrowth, liquidity: Liquidity) -> U256 {
        return toU256(bigMulDiv256(feeGrowth.v, liquidity.v, one(FeeGrowthScale + LiquidityScale)))
    }
}