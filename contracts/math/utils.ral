struct SingleTokenLiquidity {
    mut l: U256,
    mut amount: U256
}

struct LiquidityResult {
    x: U256,
    y: U256,
    l: U256
}

Contract Utils() extends Uints(), Decimal(), Log(), PoolKeyHelper(), FeeTierHelper(), Tickmap() {
    // Key: poolKey ++ subcontract index
    mapping[ByteVec, TickmapBatch] bitmap

    enum UtilsError {
        InvalidTickIndex = 900
        UpperLTCurrentSqrtPrice = 901
        CurrentLTLowerSqrtPrice = 902
    }

    enum InvariantError {
        // NotAdmin = 0
        // InsufficientLiquidity = 1
        InvalidTickSpacing = 2
        InvalidFee = 3
        // FeeTierNotFound = 4
        TokensAreSame = 5
        // PoolKeyAlreadyExist = 6
        // TickAndSqrtPriceMismatch = 7
        // NotFeeReceiver = 8
        // InvalidTickLiquidity = 9
        // ZeroLiquidity = 10
        // PriceLimitReached = 11
        // InvalidProtocolFee = 12
        // NotOwner = 13
        // ZeroAmount = 14
        // WrongPriceLimit = 15
        // NoGainSwap = 16
        // PositionDoesNotExist = 17
        // FeeTierAlreadyExist = 18
        // PoolDoesNotExist = 19
        // PoolAlreadyExist = 20
        // TickAlreadyExist = 21
        InvalidTickIndex = 22
        TickAndTickSpacingMismatch = 23
        TickLimitReached = 24
        ChunkNotFound = 25
        TickInitialized = 26
        // PositionNotFound = 27
        // EmptyPositionPokes = 28
    }

    pub fn getLiquidityByX(x: U256, lowerTick: I256, upperTick: I256, currentSqrtPrice: U256, roundingUp: Bool) -> SingleTokenLiquidity {
        assert!(lowerTick >= GlobalMinTick && upperTick <= GlobalMaxTick, UtilsError.InvalidTickIndex)
        let lowerSqrtPrice = calculateSqrtPrice(lowerTick)
        let upperSqrtPrice = calculateSqrtPrice(upperTick)

        return getLiquidityByXSqrtPrice(x, lowerSqrtPrice, upperSqrtPrice, currentSqrtPrice, roundingUp)
    }

    pub fn getLiquidityByXSqrtPrice(x: U256, lowerSqrtPrice: U256, upperSqrtPrice: U256, currentSqrtPrice: U256, roundingUp: Bool) -> SingleTokenLiquidity {
        assert!(upperSqrtPrice >= currentSqrtPrice, UtilsError.UpperLTCurrentSqrtPrice)

        let mut nominator = U512 { higher: 0, lower: 0}
        let mut denominator = 0
        let mut liquidity = 0
        if (currentSqrtPrice < lowerSqrtPrice) {
            nominator = bigMulDiv256(lowerSqrtPrice, upperSqrtPrice, one(SqrtPriceScale))
            denominator = upperSqrtPrice - lowerSqrtPrice
            liquidity = toU256(bigDiv(bigMul(bigMul(nominator,x), one(LiquidityScale)), denominator, 1))
            return SingleTokenLiquidity { l: liquidity, amount: 0 }
        }

        nominator = bigMulDiv256(currentSqrtPrice, upperSqrtPrice, one(SqrtPriceScale))
        denominator = upperSqrtPrice - currentSqrtPrice
        liquidity = toU256(bigDiv(bigMul(bigMul(nominator,x), one(LiquidityScale)), denominator, 1))
        let sqrtPriceDiff = currentSqrtPrice - lowerSqrtPrice
        let y = calculateY(sqrtPriceDiff, liquidity, roundingUp)
        return SingleTokenLiquidity { l: liquidity, amount: y }
    }

    pub fn calculateY(sqrtPriceDiff: U256, liquidity: U256, roundingUp: Bool) -> U256 {
        let shiftedLiquidity = liquidity / one(LiquidityScale)
        if (roundingUp) {
            return (sqrtPriceDiff * shiftedLiquidity + almostOne(SqrtPriceScale)) / one(SqrtPriceScale)
        } else {
            return sqrtPriceDiff * shiftedLiquidity / one(SqrtPriceScale)
        }
    }

    pub fn getLiquidityByY(y: U256, lowerTick: I256, upperTick: I256, currentSqrtPrice: U256, roundingUp: Bool) -> SingleTokenLiquidity {
        assert!(lowerTick >= GlobalMinTick && upperTick <= GlobalMaxTick, UtilsError.InvalidTickIndex)
        let lowerSqrtPrice = calculateSqrtPrice(lowerTick)
        let upperSqrtPrice = calculateSqrtPrice(upperTick)

        return getLiquidityByYSqrtPrice(y, lowerSqrtPrice, upperSqrtPrice, currentSqrtPrice, roundingUp)
    }

    pub fn getLiquidityByYSqrtPrice(y: U256, lowerSqrtPrice: U256, upperSqrtPrice: U256, currentSqrtPrice: U256, roundingUp: Bool) -> SingleTokenLiquidity {
        assert!(currentSqrtPrice >= lowerSqrtPrice, UtilsError.CurrentLTLowerSqrtPrice)

        let mut sqrtPriceDiff = 0
        let mut liquidity = 0

        if (upperSqrtPrice <= currentSqrtPrice) {
            sqrtPriceDiff = upperSqrtPrice - lowerSqrtPrice
            liquidity = toU256(bigDiv(bigMul(bigMul256(y, one(SqrtPriceScale)), one(LiquidityScale)), sqrtPriceDiff, 1))
            return SingleTokenLiquidity { l: liquidity, amount: 0 }
        }

        sqrtPriceDiff = currentSqrtPrice - lowerSqrtPrice
        liquidity = toU256(bigDiv(bigMul(bigMul256(y, one(SqrtPriceScale)), one(LiquidityScale)), sqrtPriceDiff, 1))
        let denominator = (currentSqrtPrice * upperSqrtPrice )/ one(SqrtPriceScale)
        let nominator = upperSqrtPrice - currentSqrtPrice
        let x = calculateX(nominator, denominator, liquidity, roundingUp)
        return SingleTokenLiquidity { l: liquidity, amount: x }
    }

    pub fn calculateX(nominator: U256, denominator: U256, liquidity: U256, roundingUp: Bool) -> U256 {
        let common = bigMulDiv256(liquidity, nominator, denominator)
        if (roundingUp) {
            return toU256(bigDiv(bigAdd(common, almostOne(LiquidityScale)), one(LiquidityScale), 1))
        } else {
            return toU256(bigDiv(common, one(LiquidityScale), 1))
        }
    }

    pub fn getLiquidity(x: U256, y: U256, lowerTick: I256, upperTick: I256, currentSqrtPrice: U256, roundingUp: Bool) -> LiquidityResult {
        assert!(lowerTick >= GlobalMinTick && upperTick <= GlobalMaxTick, UtilsError.InvalidTickIndex)
        let lowerSqrtPrice = calculateSqrtPrice(lowerTick)
        let upperSqrtPrice = calculateSqrtPrice(upperTick)

        let mut resultByX = SingleTokenLiquidity { l: 0, amount: 0}
        let mut resultByY = SingleTokenLiquidity { l: 0, amount: 0}

        if (upperSqrtPrice < currentSqrtPrice) {
            resultByY = getLiquidityByYSqrtPrice(y, lowerSqrtPrice, upperSqrtPrice, currentSqrtPrice, roundingUp)
            return LiquidityResult { x: resultByY.amount, y: y, l: resultByY.l } 
        } else if (currentSqrtPrice < lowerSqrtPrice) {
            resultByX = getLiquidityByXSqrtPrice(x, lowerSqrtPrice, upperSqrtPrice, currentSqrtPrice, roundingUp)
            return LiquidityResult { x: x, y: resultByX.amount, l: resultByX.l }
        } else {
            // do nothing
        }

        resultByY = getLiquidityByYSqrtPrice(y, lowerSqrtPrice, upperSqrtPrice, currentSqrtPrice, roundingUp)
        resultByX = getLiquidityByXSqrtPrice(x, lowerSqrtPrice, upperSqrtPrice, currentSqrtPrice, roundingUp)

        if(resultByY.l < resultByX.l) {
            return LiquidityResult { x: resultByY.amount, y: resultByX.amount, l: resultByY.l }
        } else {
            return LiquidityResult { x: resultByY.amount, y: resultByX.amount, l: resultByX.l }
        }
    }

    pub fn isTokenX(candidate: Address, compareTo: Address) -> Bool {
        let candidateBytes = toByteVec!(candidate)
        let compareToBytes = toByteVec!(compareTo)

        assert!(candidateBytes != compareToBytes, InvariantError.TokensAreSame)

        for (let mut i = 0; i <= size!(candidateBytes); i = i + 1) {
            if (u256From1Byte!(byteVecSlice!(candidateBytes, i, i + 1)) < u256From1Byte!(byteVecSlice!(compareToBytes, i, i + 1))) {
                return true
            } else {
                return false
            }
        }

        return true
    }

    pub fn calculateFee(
        tickLowerIndex: I256,
        tickLowerFeeGrowthOutsideX: U256,
        tickLowerFeeGrowthOutsideY: U256,
        tickUpperIndex: I256,
        tickUpperFeeGrowthOutsideX: U256,
        tickUpperFeeGrowthOutsideY: U256,
        tickCurrent: I256,
        globalFeeGrowthX: U256,
        globalFeeGrowthY: U256,
        positionFeeGrowthInsideX: U256,
        positionFeeGrowthInsideY: U256,
        positionLiquidity: U256
    ) -> (U256, U256) {
        let (feeGrowthInsideX, feeGrowthInsideY) = calculateFeeGrowthInside(
            tickLowerIndex,
            tickLowerFeeGrowthOutsideX,
            tickLowerFeeGrowthOutsideY,
            tickUpperIndex,
            tickUpperFeeGrowthOutsideX,
            tickUpperFeeGrowthOutsideY,
            tickCurrent,
            globalFeeGrowthX,
            globalFeeGrowthY
        )

        let tokensOwedX = toFee(wrappingSub(feeGrowthInsideX, positionFeeGrowthInsideX), positionLiquidity)
        let tokensOwedY = toFee(wrappingSub(feeGrowthInsideY, positionFeeGrowthInsideY), positionLiquidity)

        return tokensOwedX, tokensOwedY
    }

    pub fn toFee(feeGrowth: U256, liquidity: U256) -> U256 {
        return toU256(bigMulDiv256(feeGrowth, liquidity, one(FeeGrowthScale + LiquidityScale)))
    }
}